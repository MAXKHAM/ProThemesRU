Отлично, давайте продолжим улучшать редактор! Контекстное меню — очень полезная функция, которая значительно повышает удобство использования.

Я подготовил изменения для реализации контекстного меню, включая дублирование элементов и управление Z-индексом.

Этап 2, функция 12: контекстное меню элементов
Добавим контекстное меню, которое появляется при щелчке правой кнопкой мыши по элементу или группе на канвасе.

Появление меню: при щелчке правой кнопкой мыши (событие onContextMenu) по выбранному элементу или группе.
Действия в меню:
Удалить (Delete)
Копировать (Copy)
Вставить (Paste) — будет активно, если в буфере есть скопированные элементы.
Дублировать (Duplicate) — это новая функция, которая копирует и сразу вставляет выбранный элемент со смещением.
Группировать (Group) - активно, если выбрано >1 элементов, и они не являются частью разных групп/уже сгруппированы.
Разгруппировать (Ungroup) — активно, если выбран элемент, который является группой или частью группы.
Перенести на передний план (Bring to Front) — изменит z-index на максимальное значение.
Перенести на задний план (Send to Back) — изменит z-index на минимальное значение.
Обновления Кода:
Это затронет src/components/Editor.js, src/components/Canvas.js, src/components/Element.js, src/utils/exportUtils.js, flask_app/app.py, и мы добавим новые компоненты src/components/ContextMenu.js и стили src/styles/ContextMenu.css.

1. react-canvas-editor/src/components/Editor.js (ОБНОВЛЕНО)

 Копировать
javascript

import React, { useState, useRef, useEffect, useCallback } from 'react';
import Sidebar from './Sidebar';
import Canvas from './Canvas';
import PropertiesPanel from './PropertiesPanel';
import AIColorPaletteGenerator from './AIColorPaletteGenerator';
import LayersPanel from './LayersPanel';
import ScrapePanel from './ScrapePanel';
import ContextMenu from './ContextMenu'; // NEW: Import ContextMenu
import { generateUniqueId } from '../utils/idGenerator';
import { generateHtmlCss, cssStringToObject, objectToCssString } from '../utils/exportUtils';
import JSZip from 'jszip';
import { saveAs } from 'file-saver';

const MAX_HISTORY_SIZE = 50;
const API_BASE_URL = 'http://127.0.0.1:5000/api';

function Editor() {
  const [elements, setElements] = useState([]);
  const [selectedElementIds, setSelectedElementIds] = useState([]);
  const canvasRef = useRef(null);

  const [history, setHistory] = useState([[]]);
  const [historyIndex, setHistoryIndex] = useState(0);

  const [isAdmin, setIsAdmin] = useState(false);

  // Состояния для сетки и направляющих
  const [showGrid, setShowGrid] = useState(true);
  const [snapToGrid, setSnapToGrid] = useState(true);
  const [gridSize, setGridSize] = useState(10);
  const [snapToElements, setSnapToElements] = useState(true);
  const [snapThreshold, setSnapThreshold] = useState(5);

  const [guides, setGuides] = useState([]);

  // State for copied elements
  const [copiedElementsData, setCopiedElementsData] = useState([]);

  // NEW: State for context menu
  const [showContextMenu, setShowContextMenu] = useState(false);
  const [contextMenuPos, setContextMenuPos] = useState({ x: 0, y: 0 });
  const [contextMenuElementId, setContextMenuElementId] = useState(null);


  useEffect(() => {
    const token = localStorage.getItem('access_token');
    if (token) {
      const adminStatus = localStorage.getItem('is_admin') === 'true';
      setIsAdmin(adminStatus);
    }
  }, []);

  useEffect(() => {
    if (history[historyIndex] === elements) {
        return;
    }

    const newHistory = history.slice(0, historyIndex + 1);
    newHistory.push(elements);

    if (newHistory.length > MAX_HISTORY_SIZE) {
        newHistory.shift();    }

    setHistory(newHistory);
    setHistoryIndex(newHistory.length - 1);
  }, [elements, history, historyIndex]);

  useEffect(() => {
    try {
      const savedElements = localStorage.getItem('canvasElements');
      if (savedElements) {
        let loadedElements = JSON.parse(savedElements);
        // Ensure loaded elements have default properties for new features
        loadedElements = loadedElements.map(el => ({
            ...el,
            parentId: el.parentId === undefined ? null : el.parentId,
            props: {
                ...(el.props || {}),
                customClasses: el.props && el.props.customClasses === undefined ? [] : el.props.customClasses,
                customStyles: el.props && el.props.customStyles === undefined ? {} : el.props.customStyles,
                zIndex: el.props && el.props.zIndex === undefined ? 1 : (el.props ? el.props.zIndex : 1), // NEW: zIndex default
                // Flex properties
                displayMode: el.type === 'group' && el.props && el.props.displayMode === undefined ? 'absolute' : (el.props ? el.props.displayMode : 'absolute'),
                flexDirection: el.type === 'group' && el.props && el.props.flexDirection === undefined ? 'row' : (el.props ? el.props.flexDirection : 'row'),
                justifyContent: el.type === 'group' && el.props && el.props.justifyContent === undefined ? 'flex-start' : (el.props ? el.props.justifyContent : 'flex-start'),
                alignItems: el.type === 'group' && el.props && el.props.alignItems === undefined ? 'stretch' : (el.props ? el.props.alignItems : 'stretch'),
                gap: el.type === 'group' && el.props && el.props.gap === undefined ? '0px' : (el.props ? el.props.gap : '0px'),
                // Grid properties
                gridTemplateColumns: el.type === 'group' && el.props && el.props.gridTemplateColumns === undefined ? '1fr' : (el.props ? el.props.gridTemplateColumns : '1fr'),
                gridTemplateRows: el.type === 'group' && el.props && el.props.gridTemplateRows === undefined ? 'auto' : (el.props ? el.props.gridTemplateRows : 'auto'),
                gridGap: el.type === 'group' && el.props && el.props.gridGap === undefined ? '0px' : (el.props ? el.props.gridGap : '0px'),
                // Default border properties
                borderWidth: el.props && el.props.borderWidth === undefined ? '0px' : (el.props ? el.props.borderWidth : '0px'),
                borderStyle: el.props && el.props.borderStyle === undefined ? 'solid' : (el.props ? el.props.borderStyle : 'solid'),
                borderColor: el.props && el.props.borderColor === undefined ? '#000000' : (el.props ? el.props.borderColor : '#000000'),
                // Default box shadow properties
                boxShadowX: el.props && el.props.boxShadowX === undefined ? '0px' : (el.props ? el.props.boxShadowX : '0px'),
                boxShadowY: el.props && el.props.boxShadowY === undefined ? '0px' : (el.props ? el.props.boxShadowY : '0px'),
                boxShadowBlur: el.props && el.props.boxShadowBlur === undefined ? '0px' : (el.props ? el.props.boxShadowBlur : '0px'),
                boxShadowSpread: el.props && el.props.boxShadowSpread === undefined ? '0px' : (el.props ? el.props.boxShadowSpread : '0px'),
                boxShadowColor: el.props && el.props.boxShadowColor === undefined ? 'rgba(0,0,0,0.2)' : (el.props ? el.props.boxShadowColor : 'rgba(0,0,0,0.2)'),
                // Default background properties
                backgroundColor: el.props && el.props.backgroundColor === undefined ? '' : (el.props ? el.props.backgroundColor : ''),
                backgroundImage: el.props && el.props.backgroundImage === undefined ? '' : (el.props ? el.props.backgroundImage : ''),
                backgroundRepeat: el.props && el.props.backgroundRepeat === undefined ? 'no-repeat' : (el.props ? el.props.backgroundRepeat : 'no-repeat'),
                backgroundSize: el.props && el.props.backgroundSize === undefined ? 'cover' : (el.props ? el.props.backgroundSize : 'cover'),
                backgroundPosition: el.props && el.props.backgroundPosition === undefined ? 'center center' : (el.props ? el.props.backgroundPosition : 'center center'),
            }
        }));
        setElements(loadedElements);
        setHistory([loadedElements]);
        setHistoryIndex(0);
      }
    } catch (e) {
      console.error("Failed to load elements from localStorage", e);
    }
  }, []);

  const getElementById = useCallback((id) => {
    return elements.find(el => el.id === id);
  }, [elements]);

  const getGroupChildren = useCallback((groupId) => {
    return elements.filter(el => el.parentId === groupId);
  }, [elements]);

  const selectedElement = selectedElementIds.length === 1
    ? getElementById(selectedElementIds[0])
    : null;

  const getActiveSelection = useCallback(() => {
      if (selectedElementIds.length === 0) return { ids: [], elements: [] };

      // If only one element is selected and it's a child of a group, select the group and its children
      if (selectedElementIds.length === 1) {
          const firstSelected = getElementById(selectedElementIds[0]);
          if (firstSelected && firstSelected.parentId) {
              const group = getElementById(firstSelected.parentId);
              if (group) {
                  const children = getGroupChildren(group.id);
                  return { ids: [group.id, ...children.map(c => c.id)], elements: [group, ...children] };
              }
          }      }

      // Otherwise, just return the currently selected elements directly
      const currentSelectedElements = elements.filter(el => selectedElementIds.includes(el.id));
      return { ids: selectedElementIds, elements: currentSelectedElements };
  }, [elements, selectedElementIds, getElementById, getGroupChildren]);

  const activeSelection = getActiveSelection();


  const addElement = useCallback((type, x, y) => {
    const defaultProps = {
        name: `${type.charAt(0).toUpperCase() + type.slice(1)} ${elements.filter(el => el.type !== 'group').length + 1}`,        customClasses: [],
        customStyles: {},
        zIndex: 1, // NEW: Default zIndex
        // Default border properties
        borderWidth: '0px',
        borderStyle: 'solid',        borderColor: '#000000',
        // Default box shadow properties
        boxShadowX: '0px',
        boxShadowY: '0px',
        boxShadowBlur: '0px',
        boxShadowSpread: '0px',
        boxShadowColor: 'rgba(0,0,0,0.2)',
        // Default background properties
        backgroundColor: '',
        backgroundImage: '',
        backgroundRepeat: 'no-repeat',
        backgroundSize: 'cover',
        backgroundPosition: 'center center',
    };

    const newElement = {
      id: generateUniqueId(),
      type,
      x,
      y,
      width: 150,
      height: 50,
      parentId: null,
      props: { ...defaultProps },
    };
    switch (type) {
      case 'text':
        newElement.props = { ...newElement.props, content: 'Новый текст', fontSize: '16px', color: '#000000' };
        newElement.width = 200;
        newElement.height = 40;
        break;
      case 'image':
        newElement.props = { ...newElement.props, src: 'https://via.placeholder.com/150', alt: 'Изображение' };
        newElement.width = 150;
        newElement.height = 150;
        break;
      case 'button':
        newElement.props = { ...newElement.props, label: 'Кнопка', bgColor: '#007bff', textColor: '#ffffff' };
        newElement.width = 120;
        newElement.height = 40;
        break;
      case 'shape':
        newElement.props = { ...newElement.props, bgColor: '#ffc107', borderRadius: '0' };
        newElement.width = 100;
        newElement.height = 100;
        break;
      case 'group':
        newElement.props = {
            ...newElement.props,
            name: `Группа ${elements.filter(el => el.type === 'group').length + 1}`,
            displayMode: 'absolute',
            flexDirection: 'row',
            justifyContent: 'flex-start',
            alignItems: 'stretch',
            gap: '0px',
            gridTemplateColumns: '1fr',
            gridTemplateRows: 'auto',
            gridGap: '0px',
            backgroundColor: 'rgba(255, 255, 255, 0.05)',
            borderStyle: 'dashed',
            borderColor: 'rgba(0, 0, 0, 0.1)',
            borderWidth: '1px',
        };
        newElement.width = 250;
        newElement.height = 150;
        break;
      default:
        break;
    }

    setElements(prevElements => [...prevElements, newElement]);
    setSelectedElementIds([newElement.id]);
  }, [elements.length]);

  const updateElement = useCallback((id, updates) => {
    setElements(prevElements =>
      prevElements.map(el => (el.id === id ? { ...el, ...updates } : el))
    );
  }, []);

  const updateMultipleElements = useCallback((ids, updatesMap) => {
    setElements(prevElements =>
      prevElements.map(el => {
        if (ids.includes(el.id)) {
          const updates = updatesMap[el.id];
          return { ...el, ...updates };
        }
        return el;
      })
    );
  }, []);

  const updateElementProps = useCallback((id, newProps) => {
    setElements(prevElements =>
      prevElements.map(el => (el.id === id ? { ...el, props: { ...el.props, ...newProps } } : el))
    );
  }, []);

  const deleteElement = useCallback((id) => {
    setElements(prevElements => {
        const elementToDelete = prevElements.find(el => el.id === id);
        if (!elementToDelete) return prevElements;

        let elementsAfterDelete = prevElements.filter(el => el.id !== id);

        if (elementToDelete.type === 'group') {
            elementsAfterDelete = elementsAfterDelete.filter(el => el.parentId !== id);
        }
        return elementsAfterDelete;
    });
    setSelectedElementIds(prevIds => prevIds.filter(prevId => prevId !== id));
  }, []);

  const deleteSelectedElements = useCallback(() => {
    if (activeSelection.ids.length > 0 && window.confirm(`Вы уверены, что хотите удалить выбранные элементы (${activeSelection.elements.length})?`)) {
      setElements(prevElements => {
        let newElements = prevElements;
        activeSelection.ids.forEach(id => {
            const elToDelete = newElements.find(el => el.id === id);
            if (elToDelete) {
                newElements = newElements.filter(el => el.id !== id);
                if (elToDelete.type === 'group') {
                    newElements = newElements.filter(el => el.parentId !== id);
                }
            }
        });
        return newElements;
      });
      setSelectedElementIds([]);
    }
  }, [activeSelection]);


  const saveCanvas = useCallback(() => {
    try {
      localStorage.setItem('canvasElements', JSON.stringify(elements));
      alert('Проект сохранен!');
    } catch (e) {
      console.error("Failed to save elements to localStorage", e);
      alert('Ошибка при сохранении проекта!');
    }
  }, [elements]);

  const clearCanvas = useCallback(() => {
    if (window.confirm('Вы уверены, что хотите очистить канвас? Все несохраненные изменения будут потеряны!')) {
      setElements([]);
      setSelectedElementIds([]);
      localStorage.removeItem('canvasElements');
      alert('Канвас очищен!');
    }
  }, []);

  const exportToHtmlCss = useCallback(() => {
    const { htmlContent, cssContent } = generateHtmlCss(elements);

    const zip = new JSZip();
    zip.file("index.html", htmlContent);
    zip.file("style.css", cssContent);

    zip.generateAsync({ type: "blob" })
      .then(function (content) {
        saveAs(content, "my_design.zip");
        alert('Дизайн экспортирован в ZIP-архив!');
      })
      .catch(e => {
        console.error("Error exporting to ZIP:", e);
        alert('Ошибка при экспорте дизайна!');
      });
  }, [elements]);

  const undo = useCallback(() => {
    if (historyIndex > 0) {
      const newIndex = historyIndex - 1;
      setHistoryIndex(newIndex);
      setElements(history[newIndex]);
      setSelectedElementIds([]);
    }
  }, [history, historyIndex]);

  const redo = useCallback(() => {
    if (historyIndex < history.length - 1) {
      const newIndex = historyIndex + 1;
      setHistoryIndex(newIndex);
      setElements(history[newIndex]);
      setSelectedElementIds([]);
    }
  }, [history, historyIndex]);  const onMoveLayer = useCallback((fromIndex, toIndex) => {
    setElements(prevElements => {
      const newElements = [...prevElements];
      const [movedElement] = newElements.splice(fromIndex, 1);
      newElements.splice(toIndex, 0, movedElement);
      return newElements;
    });
  }, []);


  const alignElements = useCallback((alignment) => {    if (activeSelection.elements.length < 2) return;

    const elementsToAlign = activeSelection.elements.filter(el => el.type !== 'group');

    if (elementsToAlign.length < 2) return;
    let minX = Infinity, minY = Infinity;
    let maxX = -Infinity, maxY = -Infinity;

    elementsToAlign.forEach(el => {
      const absPos = getAbsolutePosition(el);
      minX = Math.min(minX, absPos.x);
      minY = Math.min(minY, absPos.y);
      maxX = Math.max(maxX, absPos.x + el.width);
      maxY = Math.max(maxY, absPos.y + el.height);
    });

    const boundingBoxWidth = maxX - minX;
    const boundingBoxHeight = maxY - minY;
    const boundingBoxCenterX = minX + boundingBoxWidth / 2;
    const boundingBoxCenterY = minY + boundingBoxHeight / 2;

    setElements(prevElements => {
      return prevElements.map(el => {
        if (elementsToAlign.some(item => item.id === el.id)) {
          let newX = el.x;
          let newY = el.y;

          let currentAbsX = getAbsolutePosition(el).x;
          let currentAbsY = getAbsolutePosition(el).y;

          let newAbsX = currentAbsX;
          let newAbsY = currentAbsY;

          switch (alignment) {
            case 'left':
              newAbsX = minX;
              break;
            case 'center-h':
              newAbsX = boundingBoxCenterX - el.width / 2;
              break;
            case 'right':
              newAbsX = maxX - el.width;
              break;
            case 'top':
              newAbsY = minY;
              break;
            case 'center-v':
              newAbsY = boundingBoxCenterY - el.height / 2;
              break;
            case 'bottom':
              newAbsY = maxY - el.height;
              break;
            default:
              break;
          }

          if (el.parentId) {
            const parent = getElementById(el.parentId);
            if (parent) {
                newX = newAbsX - parent.x;
                newY = newAbsY - parent.y;
            }
          } else {
            newX = newAbsX;
            newY = newAbsY;
          }
          return { ...el, x: newX, y: newY };
        }
        return el;
      });
    });
  }, [elements, activeSelection.elements, getElementById, getAbsolutePosition]);

  const distributeElements = useCallback((axis) => {
    const elementsToDistribute = activeSelection.elements
        .filter(el => el.type !== 'group')        .sort((a, b) => (axis === 'horizontal' ? getAbsolutePosition(a).x - getAbsolutePosition(b).x : getAbsolutePosition(a).y - getAbsolutePosition(b).y));

    if (elementsToDistribute.length < 3) return;

    setElements(prevElements => {
      const newElements = [...prevElements];
      const updatesMap = {};

      const firstElement = elementsToDistribute[0];
      const lastElement = elementsToDistribute[elementsToDistribute.length - 1];

      if (axis === 'horizontal') {
        const startX = getAbsolutePosition(firstElement).x;
        const endX = getAbsolutePosition(lastElement).x + lastElement.width;
        const totalWidthSpan = endX - startX;
        let totalElementsWidth = 0;
        elementsToDistribute.forEach(el => totalElementsWidth += el.width);

        const availableSpace = totalWidthSpan - totalElementsWidth;
        const spacing = availableSpace / (elementsToDistribute.length - 1);        let currentAbsX = startX;
        elementsToDistribute.forEach((el, index) => {
          let newRelativeX = el.x;
          let newRelativeY = el.y;

          if (index !== 0) {
            currentAbsX += elementsToDistribute[index - 1].width + spacing;
          }

          if (el.parentId) {
              const parent = getElementById(el.parentId);
              if (parent) {
                  newRelativeX = currentAbsX - parent.x;
              }
          } else {
              newRelativeX = currentAbsX;
          }          updatesMap[el.id] = { x: newRelativeX, y: newRelativeY };
        });
      } else { // vertical
        const startY = getAbsolutePosition(firstElement).y;        const endY = getAbsolutePosition(lastElement).y + lastElement.height;
        const totalHeightSpan = endY - startY;
        let totalElementsHeight = 0;
        elementsToDistribute.forEach(el => totalElementsHeight += el.height);

        const availableSpace = totalHeightSpan - totalElementsHeight;
        const spacing = availableSpace / (elementsToDistribute.length - 1);

        let currentAbsY = startY;
        elementsToDistribute.forEach((el, index) => {
          let newRelativeX = el.x;
          let newRelativeY = el.y;

          if (index !== 0) {
            currentAbsY += elementsToDistribute[index - 1].height + spacing;
          }

          if (el.parentId) {
              const parent = getElementById(el.parentId);
              if (parent) {
                  newRelativeY = currentAbsY - parent.y;
              }
          } else {
              newRelativeY = currentAbsY;
          }
          updatesMap[el.id] = { x: newRelativeX, y: newRelativeY };
        });
      }

      return prevElements.map(el => {
        if (updatesMap[el.id]) {
          return { ...el, ...updatesMap[el.id] };
        }
        return el;
      });
    });
  }, [elements, activeSelection.elements, getElementById, getAbsolutePosition]);  const loadMySite = useCallback(async () => {
    const token = localStorage.getItem('access_token');
    if (!token) {
      alert('Вы не авторизованы. Пожалуйста, войдите как администратор.');
      return;
    }
    if (!window.confirm('Вы уверены, что хотите загрузить сайт с сервера? Все несохраненные изменения будут потеряны!')) {
        return;
    }
    try {
      const response = await fetch(`${API_BASE_URL}/admin/load_my_site_data`, {
        headers: {
          'Authorization': `Bearer ${token}`
        }
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.msg || 'Ошибка при загрузке сайта с сервера');
      }

      let loadedElements = await response.json();
      // Ensure loaded elements have default properties for new features
      loadedElements = loadedElements.map(el => ({
          ...el,
          parentId: el.parentId === undefined ? null : el.parentId,
          props: {
              ...(el.props || {}),
              customClasses: el.props && el.props.customClasses === undefined ? [] : el.props.customClasses,
              customStyles: el.props && el.props.customStyles === undefined ? {} : el.props.customStyles,
              zIndex: el.props && el.props.zIndex === undefined ? 1 : (el.props ? el.props.zIndex : 1), // NEW: zIndex default
              // Flex properties
              displayMode: el.type === 'group' && el.props && el.props.displayMode === undefined ? 'absolute' : (el.props ? el.props.displayMode : 'absolute'),
              flexDirection: el.type === 'group' && el.props && el.props.flexDirection === undefined ? 'row' : (el.props ? el.props.flexDirection : 'row'),
              justifyContent: el.type === 'group' && el.props && el.props.justifyContent === undefined ? 'flex-start' : (el.props ? el.props.justifyContent : 'flex-start'),
              alignItems: el.type === 'group' && el.props && el.props.alignItems === undefined ? 'stretch' : (el.props ? el.props.alignItems : 'stretch'),
              gap: el.type === 'group' && el.props && el.props.gap === undefined ? '0px' : (el.props ? el.props.gap : '0px'),
              // Grid properties
              gridTemplateColumns: el.type === 'group' && el.props && el.props.gridTemplateColumns === undefined ? '1fr' : (el.props ? el.props.gridTemplateColumns : '1fr'),
              gridTemplateRows: el.type === 'group' && el.props && el.props.gridTemplateRows === undefined ? 'auto' : (el.props ? el.props.gridTemplateRows : 'auto'),
              gridGap: el.props && el.props.gridGap === undefined ? '0px' : (el.props ? el.props.gridGap : '0px'),
              // Default border properties
              borderWidth: el.props && el.props.borderWidth === undefined ? '0px' : (el.props ? el.props.borderWidth : '0px'),
              borderStyle: el.props && el.props.borderStyle === undefined ? 'solid' : (el.props ? el.props.borderStyle : 'solid'),
              borderColor: el.props && el.props.borderColor === undefined ? '#000000' : (el.props ? el.props.borderColor : '#000000'),
              // Default box shadow properties
              boxShadowX: el.props && el.props.boxShadowX === undefined ? '0px' : (el.props ? el.props.boxShadowX : '0px'),
              boxShadowY: el.props && el.props.boxShadowY === undefined ? '0px' : (el.props ? el.props.boxShadowY : '0px'),
              boxShadowBlur: el.props && el.props.boxShadowBlur === undefined ? '0px' : (el.props ? el.props.boxShadowBlur : '0px'),
              boxShadowSpread: el.props && el.props.boxShadowSpread === undefined ? '0px' : (el.props ? el.props.boxShadowSpread : '0px'),
              boxShadowColor: el.props && el.props.boxShadowColor === undefined ? 'rgba(0,0,0,0.2)' : (el.props ? el.props.boxShadowColor : 'rgba(0,0,0,0.2)'),
              // Default background properties
              backgroundColor: el.props && el.props.backgroundColor === undefined ? '' : (el.props ? el.props.backgroundColor : ''),
              backgroundImage: el.props && el.props.backgroundImage === undefined ? '' : (el.props ? el.props.backgroundImage : ''),
              backgroundRepeat: el.props && el.props.backgroundRepeat === undefined ? 'no-repeat' : (el.props ? el.props.backgroundRepeat : 'no-repeat'),
              backgroundSize: el.props && el.props.backgroundSize === undefined ? 'cover' : (el.props ? el.props.backgroundSize : 'cover'),
              backgroundPosition: el.props && el.props.backgroundPosition === undefined ? 'center center' : (el.props ? el.props.backgroundPosition : 'center center'),
          }
      }));
      setElements(loadedElements);
      setHistory([loadedElements]);
      setHistoryIndex(0);      setSelectedElementIds([]);
      alert('Сайт успешно загружен с сервера!');
    } catch (error) {
      console.error("Error loading site:", error);
      alert(`Ошибка загрузки сайта: ${error.message}`);    }
  }, []);

  const publishMySite = useCallback(async () => {
    const token = localStorage.getItem('access_token');
    if (!token) {
      alert('Вы не авторизованы. Пожалуйста, войдите как администратор.');
      return;
    }
    if (!window.confirm('Вы уверены, что хотите опубликовать текущий проект на свой сайт? Это перезапишет текущую версию сайта!')) {
        return;
    }

    try {
      const response = await fetch(`${API_BASE_URL}/admin/publish_my_site`, {
        method: 'POST',
        headers: {          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
        },
        body: JSON.stringify(elements)
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.msg || 'Ошибка при публикации сайта');
      }

      const result = await response.json();
      alert(`Сайт успешно опубликован: ${result.msg}`);
    } catch (error) {
      console.error("Error publishing site:", error);
      alert(`Ошибка публикации сайта: ${error.message}`);
    }
  }, [elements]);

  const getAbsolutePosition = useCallback((el) => {
    let currentX = el.x;
    let currentY = el.y;
    let parent = el.parentId ? elements.find(p => p.id === el.parentId) : null;

    while (parent) {
      currentX += parent.x;
      currentY += parent.y;
      parent = parent.parentId ? elements.find(p => p.id === parent.parentId) : null;
    }
    return { x: currentX, y: currentY };
  }, [elements]);

  const groupSelectedElements = useCallback(() => {      if (selectedElementIds.length < 2) return;

      const elementsToGroup = elements.filter(el => selectedElementIds.includes(el.id) && el.type !== 'group');
      if (elementsToGroup.length < 2) {
          alert('Для группировки выберите хотя бы два негруппированных элемента.');
          return;
      }

      const hasMixedParents = new Set(elementsToGroup.map(el => el.parentId)).size > 1;
      const hasParentGroupSelected = elementsToGroup.some(el => el.parentId && selectedElementIds.includes(el.parentId));

      if (hasMixedParents || hasParentGroupSelected) {
          alert('Нельзя группировать элементы из разных групп или элементы вместе с их родительскими группами. Сначала разгруппируйте их.');
          return;
      }

      let minX = Infinity, minY = Infinity;
      let maxX = -Infinity, maxY = -Infinity;

      elementsToGroup.forEach(el => {
          const absPos = getAbsolutePosition(el);
          minX = Math.min(minX, absPos.x);
          minY = Math.min(minY, absPos.y);
          maxX = Math.max(maxX, absPos.x + el.width);
          maxY = Math.max(maxY, absPos.y + el.height);
      });

      const newGroupId = generateUniqueId();
      const newGroup = {
          id: newGroupId,
          type: 'group',
          x: minX,
          y: minY,
          width: maxX - minX,
          height: maxY - minY,
          parentId: null,
          props: {
            name: `Группа ${elements.filter(el => el.type === 'group').length + 1}`,
            customClasses: [],
            customStyles: {},
            zIndex: 1, // NEW: Default zIndex for new group
            displayMode: 'absolute',
            flexDirection: 'row',
            justifyContent: 'flex-start',
            alignItems: 'stretch',
            gap: '0px',
            gridTemplateColumns: '1fr',
            gridTemplateRows: 'auto',
            gridGap: '0px',
            backgroundColor: 'rgba(255, 255, 255, 0.05)',
            borderStyle: 'dashed',
            borderColor: 'rgba(0, 0, 0, 0.1)',
            borderWidth: '1px',
            boxShadowX: '0px',
            boxShadowY: '0px',
            boxShadowBlur: '0px',
            boxShadowSpread: '0px',
            boxShadowColor: 'rgba(0,0,0,0.2)',
            backgroundImage: '',
            backgroundRepeat: 'no-repeat',
            backgroundSize: 'cover',
            backgroundPosition: 'center center',
          }      };

      setElements(prevElements => {
          return [
              ...prevElements.filter(el => !selectedElementIds.includes(el.id)),
              newGroup,
              ...elementsToGroup.map(el => {
                  const absPos = getAbsolutePosition(el);
                  return {
                      ...el,
                      parentId: newGroupId,
                      x: absPos.x - newGroup.x,                      y: absPos.y - newGroup.y,
                  };
              })
          ];
      });
      setSelectedElementIds([newGroupId]);
  }, [elements, selectedElementIds, getAbsolutePosition]);


  const ungroupElements = useCallback((groupId) => {
      const groupToUngroup = elements.find(el => el.id === groupId && el.type === 'group');
      if (!groupToUngroup) return;

      const children = elements.filter(el => el.parentId === groupId);

      setElements(prevElements => {
          const elementsWithoutGroup = prevElements.filter(el => el.id !== groupId);

          const updatedChildren = children.map(child => {
              const absPos = getAbsolutePosition(child);
              return {
                  ...child,
                  parentId: null,
                  x: absPos.x,
                  y: absPos.y,
              };
          });
          return [...elementsWithoutGroup, ...updatedChildren];
      });
      setSelectedElementIds(children.map(c => c.id));  }, [elements, getAbsolutePosition]);


  // Function to copy selected elements
  const copySelectedElements = useCallback(() => {
      if (activeSelection.elements.length === 0) {
          setCopiedElementsData([]); // Clear clipboard if nothing selected
          // alert("Нет элементов для копирования."); // Removed alert for smoother UX with context menu
          return;
      }

      const elementsToCopy = activeSelection.elements;

      const newCopiedElements = [];
      const idMap = new Map(); // Maps old element IDs to new element IDs within the copied block

      // First pass: Create new elements with new IDs and build the ID map
      elementsToCopy.forEach(el => {
          const newId = generateUniqueId();
          idMap.set(el.id, newId);
          // Deep clone the element, but don't set parentId yet, will update later
          const clonedEl = { ...el, id: newId, props: { ...(el.props || {}) } }; // Deep copy props
          newCopiedElements.push(clonedEl);
      });

      // Second pass: Update parentIds for nested elements to refer to new parent IDs
      newCopiedElements.forEach(clonedEl => {
          if (clonedEl.parentId && idMap.has(clonedEl.parentId)) {
              clonedEl.parentId = idMap.get(clonedEl.parentId);
          } else {
              // If parentId existed but parent was not copied (e.g., copying only a child of an unselected group),
              // or if it was a root element, set parentId to null.
              clonedEl.parentId = null;
          }
      });      setCopiedElementsData(newCopiedElements);
      // alert(`Скопировано ${newCopiedElements.length} элементов.`); // Removed alert
  }, [activeSelection.elements]);

  // Function to paste elements
  const pasteElements = useCallback(() => {
      if (copiedElementsData.length === 0) {
          // alert("Нет скопированных элементов для вставки."); // Removed alert
          return;
      }

      const pastedOffset = 20; // Offset for pasted elements

      const newElementsToAdd = [];
      const newSelectedIds = [];
      const idMap = new Map(); // Maps old IDs (from copiedElementsData) to new IDs (for new elements in canvas)

      // First pass: Generate new unique IDs for each element to be pasted and populate idMap
      copiedElementsData.forEach(copiedEl => {
          const newId = generateUniqueId();
          idMap.set(copiedEl.id, newId);
      });

      // Second pass: Create the actual new element objects with updated IDs and positions
      copiedElementsData.forEach(copiedEl => {
          const newEl = {
              ...copiedEl,
              id: idMap.get(copiedEl.id), // Assign the new ID
              x: copiedEl.x + pastedOffset,
              y: copiedEl.y + pastedOffset,
              props: { ...(copiedEl.props || {}) } // Deep copy props to ensure independence
          };

          // Update parentId to refer to the new ID of its new parent, if it exists in idMap
          if (copiedEl.parentId && idMap.has(copiedEl.parentId)) {
              newEl.parentId = idMap.get(copiedEl.parentId);
          } else {
              // If parentId didn't exist or parent was not part of the copied block, it's a root element
              newEl.parentId = null;
          }

          newElementsToAdd.push(newEl);
          newSelectedIds.push(newEl.id); // Select the newly pasted elements
      });

      setElements(prevElements => [...prevElements, ...newElementsToAdd]);
      setSelectedElementIds(newSelectedIds);
      // alert(`Вставлено ${newElementsToAdd.length} элементов.`); // Removed alert
  }, [copiedElementsData, setElements, setSelectedElementIds]);

  // NEW: Function to duplicate selected elements
  const duplicateSelectedElements = useCallback(() => {
    if (activeSelection.elements.length === 0) {
      alert("Нет элементов для дублирования.");
      return;
    }
    copySelectedElements(); // Copies to internal clipboard
    pasteElements(); // Pastes from internal clipboard
  }, [activeSelection.elements, copySelectedElements, pasteElements]);

  // NEW: Function to bring selected element(s) to front
  const bringToFront = useCallback(() => {
    if (activeSelection.ids.length === 0) return;

    setElements(prevElements => {
      const maxZIndex = Math.max(1, ...prevElements.map(el => el.props.zIndex || 1));
      const newElements = [...prevElements];
      const updatedIds = new Set(activeSelection.ids);
      const elementsToMove = newElements.filter(el => updatedIds.has(el.id));
      const otherElements = newElements.filter(el => !updatedIds.has(el.id));

      elementsToMove.forEach(el => {
        el.props.zIndex = maxZIndex + 1;
      });

      // Reorder elements to ensure moved elements are last (visually on top)
      return [...otherElements, ...elementsToMove];
    });
  }, [activeSelection.ids]);

  // NEW: Function to send selected element(s) to back
  const sendToBack = useCallback(() => {
    if (activeSelection.ids.length === 0) return;

    setElements(prevElements => {
      const minZIndex = Math.min(1, ...prevElements.map(el => el.props.zIndex || 1));
      const newElements = [...prevElements];
      const updatedIds = new Set(activeSelection.ids);
      const elementsToMove = newElements.filter(el => updatedIds.has(el.id));
      const otherElements = newElements.filter(el => !updatedIds.has(el.id));

      elementsToMove.forEach(el => {
        el.props.zIndex = minZIndex - 1;
      });

      // Reorder elements to ensure moved elements are first (visually at bottom)
      return [...elementsToMove, ...otherElements];
    });
  }, [activeSelection.ids]);


  const canUndo = historyIndex > 0;
  const canRedo = historyIndex < history.length - 1;

  const handleKeyDown = useCallback((e) => {
    // Prevent shortcuts from firing when typing in input fields
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
      return;
    }

    const isCtrlOrCmd = e.metaKey || e.ctrlKey; // metaKey for Mac (Cmd), ctrlKey for Windows/Linux (Ctrl)

    if (isCtrlOrCmd && e.key === 'z') {
      e.preventDefault();
      if (canUndo) {
        undo();
      }
    } else if (isCtrlOrCmd && e.shiftKey && e.key === 'Z') {
      e.preventDefault();
      if (canRedo) {
        redo();
      }
    } else if (isCtrlOrCmd && e.key === 'y') { // Common alternative for redo
      e.preventDefault();
      if (canRedo) {
        redo();
      }
    } else if (e.key === 'Delete' || e.key === 'Backspace') {
      if (selectedElementIds.length > 0) {        e.preventDefault();
        deleteSelectedElements();
      }
    } else if (isCtrlOrCmd && e.key === 's') {
      e.preventDefault();
      saveCanvas();
    } else if (isCtrlOrCmd && e.key === 'g') {
      e.preventDefault();
      if (selectedElementIds.length > 1) {
        groupSelectedElements();
      }
    } else if (isCtrlOrCmd && e.shiftKey && e.key === 'G') {
      e.preventDefault();
      if (selectedElementIds.length > 0) {
        const firstSelected = getElementById(selectedElementIds[0]);
        if (firstSelected && firstSelected.type === 'group') {
            ungroupElements(firstSelected.id);
        } else if (firstSelected && firstSelected.parentId) {
            ungroupElements(firstSelected.parentId);
        }
      }
    } else if (isCtrlOrCmd && e.key === 'c') { // Copy selected elements
        e.preventDefault();
        copySelectedElements();
    } else if (isCtrlOrCmd && e.key === 'v') { // Paste copied elements
        e.preventDefault();
        pasteElements();
    } else if (isCtrlOrCmd && e.key === 'd') { // NEW: Duplicate selected elements
        e.preventDefault();
        duplicateSelectedElements();
    }
  }, [canUndo, undo, canRedo, redo, selectedElementIds, deleteSelectedElements, saveCanvas, groupSelectedElements, ungroupElements, getElementById, copySelectedElements, pasteElements, duplicateSelectedElements]);


  useEffect(() => {
    document.addEventListener('keydown', handleKeyDown);
    return () => {
      document.removeEventListener('keydown', handleKeyDown);
    };
  }, [handleKeyDown]);

  // NEW: Context Menu handler for Canvas
  const handleCanvasContextMenu = useCallback((e, elementId = null) => {
    e.preventDefault(); // Prevent default browser context menu
    setShowContextMenu(true);
    setContextMenuPos({ x: e.clientX, y: e.clientY });
    setContextMenuElementId(elementId);
    setSelectedElementIds(elementId ? [elementId] : []); // Select element if right-clicked on it
  }, []);

  const handleCloseContextMenu = useCallback(() => {    setShowContextMenu(false);
    setContextMenuElementId(null);
  }, []);

  const elementInContextMenu = contextMenuElementId ? getElementById(contextMenuElementId) : null;
  const canGroup = selectedElementIds.length > 1 && !activeSelection.elements.some(el => el.type === 'group' || (el.parentId && selectedElementIds.includes(el.parentId)));
  const canUngroup = selectedElementIds.length > 0 && activeSelection.elements.some(el => el.type === 'group' || el.parentId);


  return (
    <div className="editor">
      <Sidebar
        addElement={addElement}
        showGrid={showGrid}
        setShowGrid={setShowGrid}
        snapToGrid={snapToGrid}
        setSnapToGrid={setSnapToGrid}
        gridSize={gridSize}
        setGridSize={setGridSize}
        snapToElements={snapToElements}
        setSnapToElements={setSnapToElements}
      />
      <Canvas
        ref={canvasRef}
        elements={elements}
        updateElement={updateElement}
        updateMultipleElements={updateMultipleElements}
        selectedElementIds={activeSelection.ids}
        setSelectedElementIds={setSelectedElementIds}        deleteElement={deleteElement}
        getAbsolutePosition={getAbsolutePosition}
        showGrid={showGrid}
        gridSize={gridSize}
        snapToGrid={snapToGrid}
        snapToElements={snapToElements}
        snapThreshold={snapThreshold}
        setGuides={setGuides}
        guides={guides}
        onContextMenu={handleCanvasContextMenu} // NEW: Pass context menu handler to Canvas
      />
      <PropertiesPanel
        selectedElement={selectedElement}
        selectedElementIds={selectedElementIds}
        activeSelection={activeSelection}
        updateElementProps={updateElementProps}
        updateElement={updateElement}
        saveCanvas={saveCanvas}
        clearCanvas={clearCanvas}
        exportToHtmlCss={exportToHtmlCss}
        undo={undo}
        redo={redo}
        canUndo={canUndo}
        canRedo={canRedo}
        deleteSelectedElements={deleteSelectedElements}
        alignElements={alignElements}
        distributeElements={distributeElements}
        isAdmin={isAdmin}
        loadMySite={loadMySite}
        publishMySite={publishMySite}
        groupSelectedElements={groupSelectedElements}
        ungroupElements={ungroupElements}
      />
      <ScrapePanel isAdmin={isAdmin} />
      <AIColorPaletteGenerator />
      <LayersPanel
        elements={elements}
        selectedElementIds={selectedElementIds}
        setSelectedElementIds={setSelectedElementIds}
        updateElement={updateElement}
        updateElementProps={updateElementProps}
        onMoveLayer={onMoveLayer}
        getAbsolutePosition={getAbsolutePosition}
      />

      {/* NEW: Context Menu */}
      {showContextMenu && (
        <ContextMenu
          x={contextMenuPos.x}
          y={contextMenuPos.y}
          onClose={handleCloseContextMenu}
          actions={[
            {
              label: 'Копировать (Ctrl+C)',
              action: copySelectedElements,
              disabled: activeSelection.ids.length === 0
            },
            {
              label: 'Вставить (Ctrl+V)',
              action: pasteElements,
              disabled: copiedElementsData.length === 0
            },
            {
              label: 'Дублировать (Ctrl+D)',
              action: duplicateSelectedElements,
              disabled: activeSelection.ids.length === 0
            },
            { type: 'separator' },
            {
              label: 'Удалить (Del)',
              action: deleteSelectedElements,
              disabled: activeSelection.ids.length === 0
            },
            { type: 'separator' },
            {
              label: 'Группировать (Ctrl+G)',
              action: groupSelectedElements,
              disabled: !canGroup
            },
            {
              label: 'Разгруппировать (Ctrl+Shift+G)',
              action: () => ungroupElements(elementInContextMenu?.type === 'group' ? elementInContextMenu.id : elementInContextMenu?.parentId),
              disabled: !canUngroup
            },
            { type: 'separator' },
            {
              label: 'На передний план',
              action: bringToFront,
              disabled: activeSelection.ids.length === 0
            },
            {
              label: 'На задний план',
              action: sendToBack,
              disabled: activeSelection.ids.length === 0
            },
          ]}
        />
      )}
    </div>
  );
}

export default Editor;
 Копировать
2. react-canvas-editor/src/components/Canvas.js (ОБНОВЛЁННЫЙ)

 Копировать
javascript

import React, { useRef, useCallback, useEffect, useState } from 'react';
import Element from './Element';
import '../styles/Canvas.css';

const Canvas = React.forwardRef(({
  elements,
  updateElement,
  updateMultipleElements,
  selectedElementIds,
  setSelectedElementIds,
  deleteElement,
  getAbsolutePosition,
  showGrid,
  gridSize,
  snapToGrid,
  snapToElements,
  snapThreshold,
  setGuides,
  guides,
  onContextMenu // NEW: Receive onContextMenu prop
}, ref) => {
  const [isDragging, setIsDragging] = useState(false);
  const [isResizing, setIsResizing] = useState(false);
  const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
  const [initialPositions, setInitialPositions] = useState({});
  const [resizingHandle, setResizingHandle] = useState(null);

  const [selectionRect, setSelectionRect] = useState(null); // For marquee selection
  const [isMarqueeSelecting, setIsMarqueeSelecting] = useState(false);

  const canvasRectRef = useRef(null); // Ref for canvas dimensions

  useEffect(() => {
    if (ref.current) {
      canvasRectRef.current = ref.current.getBoundingClientRect();
    }
  }, [ref]);

  const getSnappedPosition = useCallback((x, y) => {
    if (snapToGrid) {
      x = Math.round(x / gridSize) * gridSize;
      y = Math.round(y / gridSize) * gridSize;
    }
    return { x, y };
  }, [gridSize, snapToGrid]);

  const handleMouseDown = useCallback((e) => {
    // NEW: Close context menu if open
    // This is handled by mousedown listener on document in ContextMenu component
    // but a direct check here ensures it closes before any new actions start.
    if (e.button !== 2 && onContextMenu) { // If not right-click, tell Editor to close menu
        onContextMenu(e, null); // Pass null to indicate canvas background click
    }

    if (e.button === 2) { // Right-click
      // This event is now primarily for opening the context menu.
      // Selection logic for right-click is handled by Editor's onContextMenu.
      return;
    }

    const clickedElement = e.target.closest('.canvas-element');

    if (!clickedElement) {
      // Clicked on canvas background
      setSelectedElementIds([]);
      setIsMarqueeSelecting(true);
      const canvasRect = canvasRectRef.current;
      setSelectionRect({
        startX: e.clientX - canvasRect.left,
        startY: e.clientY - canvasRect.top,
        endX: e.clientX - canvasRect.left,
        endY: e.clientY - canvasRect.top,
      });
      return;
    }

    const elementId = clickedElement.dataset.elementId;
    const element = elements.find(el => el.id === elementId);

    if (!element) return;

    // Handle resizing
    const handle = e.target.dataset.handle;
    if (handle) {
      setIsResizing(true);
      setResizingHandle(handle);
      setDragStart({ x: e.clientX, y: e.clientY });
      setInitialPositions({
        [elementId]: {
          x: element.x,
          y: element.y,
          width: element.width,
          height: element.height
        }
      });
      return;
    }

    // Handle selection and dragging
    let newSelectedIds = [...selectedElementIds];
    if (e.metaKey || e.ctrlKey) { // Ctrl/Cmd click for multi-selection
      if (newSelectedIds.includes(elementId)) {
        newSelectedIds = newSelectedIds.filter(id => id !== elementId);
      } else {
        newSelectedIds.push(elementId);
      }
    } else { // Single selection
      if (!newSelectedIds.includes(elementId)) {
        newSelectedIds = [elementId];
      }
    }

    setSelectedElementIds(newSelectedIds);

    setIsDragging(true);
    setDragStart({ x: e.clientX, y: e.clientY });

    const initialPosMap = {};
    const elementsToDrag = elements.filter(el => newSelectedIds.includes(el.id));
    elementsToDrag.forEach(el => {
      initialPosMap[el.id] = { x: el.x, y: el.y };
    });
    setInitialPositions(initialPosMap);
  }, [elements, selectedElementIds, setSelectedElementIds, gridSize, snapToGrid, snapToElements, snapThreshold, getAbsolutePosition, onContextMenu]);


  const handleMouseMove = useCallback((e) => {
    if (isMarqueeSelecting) {
      const canvasRect = canvasRectRef.current;
      setSelectionRect(prev => ({        ...prev,
        endX: e.clientX - canvasRect.left,
        endY: e.clientY - canvasRect.top,
      }));
      return;
    }

    if (!isDragging && !isResizing) return;

    const dx = e.clientX - dragStart.x;
    const dy = e.clientY - dragStart.y;

    const canvasRect = canvasRectRef.current;

    if (isDragging) {
      const updates = {};
      selectedElementIds.forEach(id => {
        const initialPos = initialPositions[id];
        if (initialPos) {
          let newX = initialPos.x + dx;
          let newY = initialPos.y + dy;

          if (snapToGrid) {
            newX = Math.round(newX / gridSize) * gridSize;
            newY = Math.round(newY / gridSize) * gridSize;
          }

          if (snapToElements && selectedElementIds.length === 1) {
            const currentElement = elements.find(el => el.id === id);
            const snapped = snapElementToOthers(currentElement, newX, newY, elements, getAbsolutePosition, snapThreshold);
            newX = snapped.x;
            newY = snapped.y;
            setGuides(snapped.guides);
          } else {
            setGuides([]);
          }

          // Convert back to relative if parented
          const element = elements.find(el => el.id === id);
          if (element && element.parentId) {
            const parent = elements.find(p => p.id === element.parentId);
            if (parent) {
              newX -= parent.x;
              newY -= parent.y;
            }
          }
          updates[id] = { x: newX, y: newY };
        }
      });
      updateMultipleElements(selectedElementIds, updates);
    } else if (isResizing && selectedElementIds.length === 1) {
      const elementId = selectedElementIds[0];
      const element = elements.find(el => el.id === elementId);
      const initial = initialPositions[elementId];

      if (!element || !initial) return;

      let newX = initial.x;
      let newY = initial.y;
      let newWidth = initial.width;
      let newHeight = initial.height;

      // Calculate new dimensions and position based on handle
      switch (resizingHandle) {
        case 'br':
          newWidth = Math.max(10, initial.width + dx);
          newHeight = Math.max(10, initial.height + dy);
          break;
        case 'bl':
          newWidth = Math.max(10, initial.width - dx);
          newHeight = Math.max(10, initial.height + dy);
          newX = initial.x + dx;
          break;        case 'tr':
          newWidth = Math.max(10, initial.width + dx);
          newHeight = Math.max(10, initial.height - dy);
          newY = initial.y + dy;
          break;
        case 'tl':
          newWidth = Math.max(10, initial.width - dx);
          newHeight = Math.max(10, initial.height - dy);
          newX = initial.x + dx;
          newY = initial.y + dy;
          break;
        case 't':
          newHeight = Math.max(10, initial.height - dy);
          newY = initial.y + dy;
          break;
        case 'b':
          newHeight = Math.max(10, initial.height + dy);
          break;        case 'l':
          newWidth = Math.max(10, initial.width - dx);
          newX = initial.x + dx;
          break;
        case 'r':
          newWidth = Math.max(10, initial.width + dx);
          break;
        default:
          break;
      }

      // Snap to grid for resizing
      if (snapToGrid) {
        newX = Math.round(newX / gridSize) * gridSize;
        newY = Math.round(newY / gridSize) * gridSize;
        newWidth = Math.round(newWidth / gridSize) * gridSize;
        newHeight = Math.round(newHeight / gridSize) * gridSize;
      }

      updateElement(elementId, { x: newX, y: newY, width: newWidth, height: newHeight });
    }
  }, [isDragging, isResizing, dragStart, initialPositions, selectedElementIds, updateMultipleElements, updateElement, resizingHandle, elements, snapToGrid, gridSize, snapToElements, snapThreshold, getAbsolutePosition, isMarqueeSelecting]);

  const handleMouseUp = useCallback((e) => {
    if (isMarqueeSelecting) {
      const canvasRect = canvasRectRef.current;      const rect = {
        x: Math.min(selectionRect.startX, selectionRect.endX),
        y: Math.min(selectionRect.startY, selectionRect.endY),
        width: Math.abs(selectionRect.endX - selectionRect.startX),
        height: Math.abs(selectionRect.endY - selectionRect.startY),
      };

      const newSelectedIds = elements.filter(el => {
        const absPos = getAbsolutePosition(el);
        return (
          absPos.x < rect.x + rect.width &&
          absPos.x + el.width > rect.x &&
          absPos.y < rect.y + rect.height &&
          absPos.y + el.height > rect.y
        );
      }).map(el => el.id);

      setSelectedElementIds(newSelectedIds);
      setSelectionRect(null);
      setIsMarqueeSelecting(false);
    }

    setIsDragging(false);
    setIsResizing(false);
    setResizingHandle(null);
    setInitialPositions({});
    setGuides([]);
  }, [isMarqueeSelecting, selectionRect, elements, setSelectedElementIds, getAbsolutePosition]);

  // Handle right-click on an element
  const handleElementContextMenu = useCallback((e, elementId) => {
    e.stopPropagation(); // Prevent canvas context menu from opening as well
    onContextMenu(e, elementId); // Pass the elementId to the Editor's handler
  }, [onContextMenu]);


  // Marquee selection styles
  const marqueeStyle = selectionRect ? {
    left: Math.min(selectionRect.startX, selectionRect.endX),
    top: Math.min(selectionRect.startY, selectionRect.endY),
    width: Math.abs(selectionRect.endX - selectionRect.startX),
    height: Math.abs(selectionRect.endY - selectionRect.startY),
  } : {};

  return (
    <div
      className="canvas-container"
      ref={ref}
      onMouseDown={handleMouseDown}
      onMouseMove={handleMouseMove}
      onMouseUp={handleMouseUp}
      onMouseLeave={handleMouseUp} // End drag/resize if mouse leaves canvas
      onContextMenu={e => onContextMenu(e, null)} // NEW: Context menu for canvas background    >
      {showGrid && (
        <div className="grid-overlay" style={{
          backgroundSize: `${gridSize}px ${gridSize}px`,
          backgroundImage: `
            linear-gradient(to right, #444 1px, transparent 1px),
            linear-gradient(to bottom, #444 1px, transparent 1px)
          `
        }} />
      )}

      {elements.map((element) => (
        <Element
          key={element.id}
          element={element}
          isSelected={selectedElementIds.includes(element.id)}
          isActivelyDragging={isDragging && selectedElementIds.includes(element.id)}
          resizingHandle={isResizing && selectedElementIds.includes(element.id) ? resizingHandle : null}
          getAbsolutePosition={getAbsolutePosition}
          onContextMenu={handleElementContextMenu} // NEW: Pass context menu handler to Element
        />
      ))}

      {guides.map((guide, index) => (
        <div
          key={index}
          className={`guide ${guide.orientation}`}
          style={{ [guide.orientation === 'vertical' ? 'left' : 'top']: guide.position }}
        />
      ))}

      {isMarqueeSelecting && (
        <div className="selection-marquee" style={marqueeStyle}></div>
      )}
    </div>
  );
});

export default Canvas;


function snapElementToOthers(currentElement, newX, newY, allElements, getAbsolutePosition, threshold) {
  const guides = [];
  let snappedX = newX;
  let snappedY = newY;

  const currentAbs = {
    x: newX, y: newY,
    right: newX + currentElement.width,
    bottom: newY + currentElement.height,
    centerX: newX + currentElement.width / 2,
    centerY: newY + currentElement.height / 2
  };

  allElements.forEach(otherElement => {
    if (currentElement.id === otherElement.id || currentElement.parentId === otherElement.id || otherElement.parentId === currentElement.id) return;

    const otherAbs = getAbsolutePosition(otherElement);
    otherAbs.right = otherAbs.x + otherElement.width;
    otherAbs.bottom = otherAbs.y + otherElement.height;
    otherAbs.centerX = otherAbs.x + otherElement.width / 2;
    otherAbs.centerY = otherAbs.y + otherElement.height / 2;

    // Snap horizontally
    // Left to Left
    if (Math.abs(currentAbs.x - otherAbs.x) < threshold) {
      snappedX = otherAbs.x;
      guides.push({ orientation: 'vertical', position: otherAbs.x });
    }
    // Right to Right
    else if (Math.abs(currentAbs.right - otherAbs.right) < threshold) {
      snappedX = otherAbs.right - currentElement.width;
      guides.push({ orientation: 'vertical', position: otherAbs.right });
    }
    // Left to Right
    else if (Math.abs(currentAbs.x - otherAbs.right) < threshold) {
      snappedX = otherAbs.right;
      guides.push({ orientation: 'vertical', position: otherAbs.right });
    }
    // Right to Left
    else if (Math.abs(currentAbs.right - otherAbs.x) < threshold) {
      snappedX = otherAbs.x - currentElement.width;
      guides.push({ orientation: 'vertical', position: otherAbs.x });
    }
    // Center X
    else if (Math.abs(currentAbs.centerX - otherAbs.centerX) < threshold) {
      snappedX = otherAbs.centerX - currentElement.width / 2;
      guides.push({ orientation: 'vertical', position: otherAbs.centerX });
    }

    // Snap vertically
    // Top to Top    if (Math.abs(currentAbs.y - otherAbs.y) < threshold) {
      snappedY = otherAbs.y;
      guides.push({ orientation: 'horizontal', position: otherAbs.y });
    }
    // Bottom to Bottom
    else if (Math.abs(currentAbs.bottom - otherAbs.bottom) < threshold) {
      snappedY = otherAbs.bottom - currentElement.height;
      guides.push({ orientation: 'horizontal', position: otherAbs.bottom });
    }
    // Top to Bottom
    else if (Math.abs(currentAbs.y - otherAbs.bottom) < threshold) {
      snappedY = otherAbs.bottom;
      guides.push({ orientation: 'horizontal', position: otherAbs.bottom });
    }
    // Bottom to Top
    else if (Math.abs(currentAbs.bottom - otherAbs.y) < threshold) {
      snappedY = otherAbs.y - currentElement.height;
      guides.push({ orientation: 'horizontal', position: otherAbs.y });
    }
    // Center Y
    else if (Math.abs(currentAbs.centerY - otherAbs.centerY) < threshold) {
      snappedY = otherAbs.centerY - currentElement.height / 2;
      guides.push({ orientation: 'horizontal', position: otherAbs.centerY });
    }
  });

  return { x: snappedX, y: snappedY, guides };
}```

**3. `react-canvas-editor/src/components/Element.js` (ОБНОВЛЕННЫЙ)**

```javascript
import React, { useMemo } from 'react';
import '../styles/Element.css';
import { objectToCssString } from '../utils/exportUtils';

function Element({ element, isSelected, isActivelyDragging, resizingHandle, getAbsolutePosition, onContextMenu }) { // NEW: Receive onContextMenu
  const { id, type, x, y, width, height, parentId, props } = element;

  const absolutePosition = useMemo(() => {
    return getAbsolutePosition(element);
  }, [element, getAbsolutePosition]);

  // Вычисляем стили для отображения на канвасе
  const elementStyle = useMemo(() => {
    let styles = {
      left: absolutePosition.x,
      top: absolutePosition.y,
      width: width,
      height: height,
      zIndex: props.zIndex || 1, // NEW: Apply z-index from props
      // Apply Background properties
      backgroundColor: props.backgroundColor || '',
      backgroundImage: props.backgroundImage ? `url('${props.backgroundImage}')` : 'none',
      backgroundRepeat: props.backgroundRepeat || 'no-repeat',
      backgroundSize: props.backgroundSize || 'cover',
      backgroundPosition: props.backgroundPosition || 'center center',
    };

    // Apply specific styles based on type (if not overridden by group)
    if (type === 'text') {
      styles.fontSize = props.fontSize;
      styles.color = props.color;
    } else if (type === 'button') {
      styles.backgroundColor = props.bgColor;
      styles.color = props.textColor;
    } else if (type === 'shape') {
      styles.backgroundColor = props.bgColor;
      styles.borderRadius = props.borderRadius;
    }

    // Apply Border properties
    if (props.borderWidth && props.borderWidth !== '0px') {
        styles.border = `${props.borderWidth} ${props.borderStyle || 'solid'} ${props.borderColor || '#000000'}`;
    } else {
        styles.border = 'none'; // Ensure no border if width is 0
    }

    // Apply Box Shadow properties
    if (props.boxShadowX || props.boxShadowY || props.boxShadowBlur || props.boxShadowSpread) {
        styles.boxShadow = `${props.boxShadowX || '0px'} ${props.boxShadowY || '0px'} ${props.boxShadowBlur || '0px'} ${props.boxShadowSpread || '0px'} ${props.boxShadowColor || 'rgba(0,0,0,0.2)'}`;    } else {
        styles.boxShadow = 'none';
    }

    // Apply custom styles last to allow override
    if (props.customStyles) {
      Object.assign(styles, props.customStyles);
    }

    return styles;
  }, [element, absolutePosition, width, height, props, type]);

  const elementClasses = useMemo(() => {
    let classes = `canvas-element element-${type}`;
    if (isSelected) classes += ' selected';
    if (isActivelyDragging) classes += ' dragging';
    if (resizingHandle) classes += ' resizing';
    if (props.customClasses && props.customClasses.length > 0) {
      classes += ` ${props.customClasses.join(' ')}`;
    }
    return classes;
  }, [isSelected, isActivelyDragging, resizingHandle, props.customClasses, type]);

  const renderContent = () => {
    switch (type) {
      case 'text':
        return <div dangerouslySetInnerHTML={{ __html: props.content }} className="text-element" />;
      case 'image':
        return <img src={props.src} alt={props.alt} className="image-element" />;
      case 'button':
        return <button className="button-element">{props.label}</button>;
      case 'shape':
        return <div className="shape-element"></div>;
      case 'group':
        return <div className="group-placeholder">{props.name}</div>; // Display group name for clarity
      default:
        return <div>Unknown Element</div>;
    }
  };

  return (
    <div
      id={id}
      className={elementClasses}
      style={elementStyle} // Применяем вычисленные стили
      data-element-id={id}
      onContextMenu={(e) => onContextMenu(e, id)} // NEW: Pass element ID to context menu handler
    >
      {renderContent()}
      {isSelected && (
        <>
          <div className="resizer top-left" data-handle="tl"></div>
          <div className="resizer top-right" data-handle="tr"></div>
          <div className="resizer bottom-left" data-handle="bl"></div>
          <div className="resizer bottom-right" data-handle="br"></div>          <div className="resizer top" data-handle="t"></div>
          <div className="resizer bottom" data-handle="b"></div>
          <div className="resizer left" data-handle="l"></div>
          <div className="resizer right" data-handle="r"></div>
        </>
      )}
    </div>
  );
}

export default Element;
 Копировать
4. react-canvas-editor/src/components/ContextMenu.js (НОВЫЙ ФАЙЛ)

Создайте этот файл в src/components/.

 Копировать
javascript

import React, { useEffect, useRef } from 'react';
import '../styles/ContextMenu.css'; // Создадим этот CSS файл ниже

function ContextMenu({ x, y, onClose, actions }) {
  const menuRef = useRef(null);

  useEffect(() => {
    const handleClickOutside = (event) => {
      if (menuRef.current && !menuRef.current.contains(event.target)) {
        onClose();
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    // document.addEventListener('contextmenu', handleClickOutside); // Also close on right-click outside

    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
      // document.removeEventListener('contextmenu', handleClickOutside);
    };
  }, [onClose]);

  // Adjust menu position if it goes off-screen
  useEffect(() => {
    if (menuRef.current) {
      const { innerWidth, innerHeight } = window;
      const { offsetWidth, offsetHeight } = menuRef.current;

      let newX = x;
      let newY = y;

      if (x + offsetWidth > innerWidth) {
        newX = innerWidth - offsetWidth - 10; // 10px padding from edge
      }
      if (y + offsetHeight > innerHeight) {
        newY = innerHeight - offsetHeight - 10; // 10px padding from edge
      }

      // Ensure it doesn't go off left/top if initial x/y were very small
      newX = Math.max(0, newX);
      newY = Math.max(0, newY);

      menuRef.current.style.left = `${newX}px`;
      menuRef.current.style.top = `${newY}px`;
    }
  }, [x, y]);

  return (
    <div className="context-menu" style={{ left: x, top: y }} ref={menuRef}>
      {actions.map((item, index) => (
        item.type === 'separator' ? (
          <div key={`separator-${index}`} className="context-menu-separator" />
        ) : (
          <button
            key={index}
            className="context-menu-item"
            onClick={() => {
              if (!item.disabled) {
                item.action();
                onClose();
              }
            }}
            disabled={item.disabled}
          >
            {item.label}
          </button>
        )
      ))}
    </div>
  );
}

export default ContextMenu;
 Копировать
5. react-canvas-editor/src/styles/ContextMenu.css (НОВЫЙ ФАЙЛ)

Создайте этот файл в src/styles/.

 Копировать
css

.context-menu {
    position: fixed; /* Use fixed to position relative to viewport */
    background-color: #3a3a3a;
    border: 1px solid #555;
    border-radius: 5px;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
    z-index: 1000; /* Ensure it's on top of other elements */
    padding: 5px 0;
    min-width: 180px;
    display: flex;
    flex-direction: column;
}

.context-menu-item {
    background-color: transparent;
    color: #f0f0f0;
    border: none;
    padding: 8px 15px;
    text-align: left;
    width: 100%;
    cursor: pointer;
    font-size: 0.9em;
    white-space: nowrap; /* Prevent text wrapping */
    transition: background-color 0.1s ease;
}

.context-menu-item:hover:not(:disabled) {
    background-color: #007bff;
}

.context-menu-item:disabled {
    color: #888;
    cursor: not-allowed;
    opacity: 0.7;
}

.context-menu-separator {
    height: 1px;
    background-color: #555;
    margin: 5px 0;
}
 Копировать
6. react-canvas-editor/src/utils/exportUtils.js (ОБНОВЛЕНО)

 Копировать
javascript

// src/utils/exportUtils.js
const MAX_CONTAINER_WIDTH = 960; // Максимальная ширина для адаптивного контейнера

export function cssStringToObject(cssString) {
    const styles = {};
    if (!cssString) return styles;

    cssString = cssString.replace(/\/\*[\s\S]*?\*\/|([^:]|^)\/\/.*$/gm, '$1');

    const parts = cssString.split(';');
    parts.forEach(part => {
        const trimmedPart = part.trim();
        if (trimmedPart) {
            const colonIndex = trimmedPart.indexOf(':');
            if (colonIndex > 0) {
                const key = trimmedPart.substring(0, colonIndex).trim();
                const value = trimmedPart.substring(colonIndex + 1).trim();
                if (key && value) {
                    styles[key] = value;
                }
            }
        }
    });
    return styles;
}

export function objectToCssString(cssObject) {
    if (!cssObject) return "";
    return Object.entries(cssObject)
        .map(([key, value]) => `${key}: ${value}`)
        .join('; ') + (Object.keys(cssObject).length > 0 ? ';' : '');
}


export function generateHtmlCss(elements) {
    const elementMap = new Map(elements.map(el => [el.id, el]));
    
    // Sort elements by zIndex before rendering to ensure correct layering in HTML
    // This is important because elements are positioned absolutely and z-index only works if order is correct or z-index is explicitly set.
    // We will set z-index explicitly.
    const sortedElements = [...elements].sort((a, b) => (a.props.zIndex || 1) - (b.props.zIndex || 1));
    const sortedRootElements = sortedElements.filter(el => !el.parentId);


    let minX = Infinity, minY = Infinity;
    let maxX = -Infinity, maxY = -Infinity;
    if (elements.length > 0) { // Calculate bounds based on all elements, not just root
        elements.forEach(el => { // Changed to all elements for more accurate bounding box
            minX = Math.min(minX, el.x);
            minY = Math.min(minY, el.y);
            maxX = Math.max(maxX, el.x + el.width);
            maxY = Math.max(maxY, el.y + el.height);
        });
    } else {
        minX = 0; minY = 0; maxX = MAX_CONTAINER_WIDTH; maxY = 300;
    }

    const originalDesignWidth = maxX - minX;
    const originalDesignHeight = maxY - minY;

    const scaleFactor = originalDesignWidth > MAX_CONTAINER_WIDTH && originalDesignWidth > 0
        ? MAX_CONTAINER_WIDTH / originalDesignWidth
        : 1;

    const scaledContainerHeight = originalDesignHeight * scaleFactor;

    let htmlContent = `<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Мой Сайт (ProThemesRU)</title>
    <link rel="stylesheet" href="style.css">
    <style>
        /* Базовые стили для элементов конструктора */
        .canvas-element {
            box-sizing: border-box;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        /* Only for elements that are absolutely positioned */
        .canvas-element[style*="position: absolute;"] {
             position: absolute;
        }

        .canvas-element > * {
            width: 100%;
            height: 100%;
            box-sizing: border-box;
        }

        .text-element {
            text-align: center;
            word-break: break-word;
            padding: 5px;
        }
        .image-element {
            display: block;
            object-fit: contain;
            max-width: 100%;
            height: auto;
        }
        .button-element {
            padding: 8px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            white-space: nowrap;
        }
        .shape-element {
            /* background-color and border-radius are inline */
        }
    </style>
</head>
<body>
    <div id="main-content-area">
`;
    let cssContent = `
body {
    margin: 0;
    padding: 0;
    font-family: Arial, sans-serif;    background-color: #f0f0f0;
    min-height: 100vh;
    display: flex;
    justify-content: center;
    align-items: flex-start;
    padding: 20px 0;
    box-sizing: border-box;
}

#main-content-area {
    position: relative;
    max-width: ${MAX_CONTAINER_WIDTH}px;
    width: 100%;
    margin: 0 auto;
    min-height: ${Math.max(scaledContainerHeight, 200)}px;
    background-color: #ffffff;
    box-shadow: 0 0 15px rgba(0, 0, 0, 0.1);
    border-radius: 8px;
    overflow: hidden;
}
`;
    // Recursive function to render elements
    function renderElementHtmlAndCss(element) {
        // Children should also be sorted by z-index if they are rendered within a group
        const children = sortedElements.filter(el => el.parentId === element.id);

        let inlineStyles = '';
        let elementClasses = 'canvas-element';

        const parent = element.parentId ? elementMap.get(element.parentId) : null;
        const isChildOfFlexContainer = parent && parent.type === 'group' && parent.props.displayMode === 'flex';
        const isChildOfGridContainer = parent && parent.type === 'group' && parent.props.displayMode === 'grid';

        if (isChildOfFlexContainer || isChildOfGridContainer) {
            inlineStyles += `width: ${element.width}px; height: ${element.height}px;`;
        } else {
            const elX = element.x;
            const elY = element.y;
            const newX = (element.parentId === null) ? (elX - minX) * scaleFactor : elX;
            const newY = (element.parentId === null) ? (elY - minY) * scaleFactor : elY;
            const newWidth = (element.parentId === null) ? element.width * scaleFactor : element.width;
            const newHeight = (element.parentId === null) ? element.height * scaleFactor : element.height;

            inlineStyles += `position: absolute; left: ${newX}px; top: ${newY}px; width: ${newWidth}px; height: ${newHeight}px;`;
        }

        // NEW: Apply z-index
        if (element.props.zIndex !== undefined) {
            inlineStyles += ` z-index: ${element.props.zIndex};`;
        }

        if (element.props.customClasses && element.props.customClasses.length > 0) {
            elementClasses += ` ${element.props.customClasses.join(' ')}`;
        }

        let innerHtml = '';
        switch (element.type) {
            case 'text':
                innerHtml = `<div class="text-element">${element.props.content || ''}</div>`;
                inlineStyles += ` font-size: ${element.props.fontSize || '16px'}; color: ${element.props.color || '#000000'};`;
                break;
            case 'image':
                innerHtml = `<img src="${element.props.src || ''}" alt="${element.props.alt || ''}" class="image-element">`;
                break;
            case 'button':
                innerHtml = `<button class="button-element">${element.props.label || ''}</button>`;
                inlineStyles += ` background-color: ${element.props.bgColor || '#007bff'}; color: ${element.props.textColor || '#ffffff'};`;
                break;
            case 'shape':
                innerHtml = `<div class="shape-element"></div>`;
                inlineStyles += ` background-color: ${element.props.bgColor || '#ffc107'}; border-radius: ${element.props.borderRadius || '0'};`;
                break;
            case 'group':
                elementClasses += ' group-element';
                if (element.props.displayMode === 'flex') {
                    inlineStyles += ` display: flex;`;
                    if (element.props.flexDirection) inlineStyles += ` flex-direction: ${element.props.flexDirection};`;
                    if (element.props.justifyContent) inlineStyles += ` justify-content: ${element.props.justifyContent};`;
                    if (element.props.alignItems) inlineStyles += ` align-items: ${element.props.alignItems};`;
                    if (element.props.gap) inlineStyles += ` gap: ${element.props.gap};`;
                } else if (element.props.displayMode === 'grid') {
                    inlineStyles += ` display: grid;`;                    if (element.props.gridTemplateColumns) inlineStyles += ` grid-template-columns: ${element.props.gridTemplateColumns};`;
                    if (element.props.gridTemplateRows) inlineStyles += ` grid-template-rows: ${element.props.gridTemplateRows};`;
                    if (element.props.gridGap) inlineStyles += ` gap: ${element.props.gridGap};`;
                } else {
                    inlineStyles += ` position: absolute;`;
                }

                innerHtml = children.map(child => renderElementHtmlAndCss(child)).join('\n');
                break;
            default:
                innerHtml = `<div>Unknown Element</div>`;
        }

        // Apply Border properties
        if (element.props.borderWidth && element.props.borderWidth !== '0px' &&
           element.props.borderStyle && element.props.borderColor) {
            inlineStyles += ` border: ${element.props.borderWidth} ${element.props.borderStyle} ${element.props.borderColor};`;
        }

        // Apply Box Shadow properties
        if (element.props.boxShadowX || element.props.boxShadowY || element.props.boxShadowBlur || element.props.boxShadowSpread) {
            inlineStyles += ` box-shadow: ${element.props.boxShadowX || '0px'} ${element.props.boxShadowY || '0px'} ${element.props.boxShadowBlur || '0px'} ${element.props.boxShadowSpread || '0px'} ${element.props.boxShadowColor || 'rgba(0,0,0,0.2)'};`;
        }
        // Apply Background properties
        if (element.props.backgroundColor) {            inlineStyles += ` background-color: ${element.props.backgroundColor};`;
        }
        if (element.props.backgroundImage) {
            inlineStyles += ` background-image: url('${element.props.backgroundImage}');`;
            inlineStyles += ` background-repeat: ${element.props.backgroundRepeat || 'no-repeat'};`;
            inlineStyles += ` background-size: ${element.props.backgroundSize || 'cover'};`;            inlineStyles += ` background-position: ${element.props.backgroundPosition || 'center center'};`;
        }

        // Apply custom styles last to allow override
        if (element.props.customStyles) {            inlineStyles += ` ${objectToCssString(element.props.customStyles)}`;
        }

        return `        <div id="${element.id}" class="${element_classes}" style="${inlineStyles}">${innerHtml}</div>`;
    }

    htmlContent += sortedRootElements.map(el => renderElementHtmlAndCss(el)).join('\n');

    htmlContent += `    </div>
</body>
</html>`;

    return { htmlContent, cssContent };
}
 Копировать
7. flask_app/app.py (ОБНОВЛЕНО)

 Копировать
питон

from flask import Flask, request, jsonify, send_from_directory
from flask_cors import CORS
import os
import json
import re
import requests
from bs4 import BeautifulSoup
from flask_jwt_extended import JWTManager, jwt_required, create_access_token, get_jwt_identity, get_jwt

# --- КОНФИГУРАЦИЯ ---
app = Flask(__name__)
CORS(app)

# Конфигурация JWT
app.config["JWT_SECRET_KEY"] = "your-super-secret-jwt-key" # !!! Замените на реальный секретный ключ !!!
jwt = JWTManager(app)

SITE_DATA_FILE = 'site_data.json'
PUBLIC_SITE_DIR = os.path.join(app.root_path, 'public_site')
SCRAPING_PROFILES_FILE = 'scraping_profiles.json' # NEW: File for scraping profiles
PUBLIC_SCRAPED_SITES_DIR = os.path.join(app.root_path, 'public_scraped_sites') # NEW: Directory for scraped sites

# Ensure directories exist
if not os.path.exists(PUBLIC_SITE_DIR):
    os.makedirs(PUBLIC_SITE_DIR)
if not os.path.exists(PUBLIC_SCRAPED_SITES_DIR):
    os.makedirs(PUBLIC_SCRAPED_SITES_DIR)

# --- ВРЕМЕННЫЙ МЕХАНИЗМ АДМИНА (ДЛЯ ТЕСТОВ) ---
users = {
    "testuser": {"password": "password123", "is_admin": False},
    "admin": {"password": "adminpassword", "is_admin": True}
}

@jwt.user_lookup_loader
def user_lookup_callback(_jwt_header, jwt_data):
    identity = jwt_data["sub"]
    return users.get(identity)

@jwt.additional_claims_loader
def add_claims_to_access_token(identity):
    user_data = users.get(identity)
    if user_data:
        return {"is_admin": user_data.get("is_admin", False)}
    return {"is_admin": False}


# --- МАРШРУТЫ АУТЕНТИФИКАЦИИ ---
@app.route("/login", methods=["POST"])
def login():
    username = request.json.get("username", None)
    password = request.json.get("password", None)

    user = users.get(username)
    if not user or user["password"] != password:
        return jsonify({"msg": "Bad username or password"}), 401
    access_token = create_access_token(identity=username)
    return jsonify(access_token=access_token, is_admin=user["is_admin"])@app.route("/protected", methods=["GET"])
@jwt_required()
def protected():
    current_user = get_jwt_identity()
    claims = get_jwt()
    is_admin = claims.get("is_admin", False)
    return jsonify(logged_in_as=current_user, is_admin=is_admin), 200

# --- ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ ДЛЯ CSS (Python-реализация) ---
def css_string_to_object(css_string):
    styles = {}
    if not css_string:
        return styles
        css_string = re.sub(r'\/\*[\s\S]*?\*\/|([^:]|^)\/\/.*$', r'\1', css_string)

    parts = css_string.split(';')
    for part in parts:
        trimmed_part = part.strip()
        if trimmed_part:
            if ':' in trimmed_part:
                key, value = trimmed_part.split(':', 1)
                styles[key.strip()] = value.strip()
    return styles

def object_to_css_string(css_object):
    if not css_object:
        return ""
    return "; ".join([f"{key}: {value}" for key, value in css_object.items()]) + (";" if css_object else "")


# --- ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ ДЛЯ ГЕНЕРАЦИИ HTML/CSS ---
def _generate_html_css_from_elements(elements):
    """
    Генерирует HTML и CSS из массива элементов конструктора,
    используя адаптивный контейнер и вложенность для групп.
    """
    MAX_CONTAINER_WIDTH = 960

    element_map = {el['id']: el for el in elements}
    
    # NEW: Sort elements by zIndex before rendering
    # Ensure all elements have a zIndex for sorting
    for el in elements:
        if 'props' not in el: el['props'] = {}
        if 'zIndex' not in el['props']: el['props']['zIndex'] = 1

    sorted_elements = sorted(elements, key=lambda x: x['props'].get('zIndex', 1))
    root_elements = [el for el in sorted_elements if not el.get('parentId')]


    minX = float('inf')
    minY = float('inf')
    maxX = float('-inf')
    maxY = float('-inf')

    if elements: # Use all elements for bounding box calculation
        for el in elements:
            minX = min(minX, el['x'])
            minY = min(minY, el['y'])
            maxX = max(maxX, el['x'] + el['width'])
            maxY = max(maxY, el['y'] + el['height'])
    else:
        minX = 0; minY = 0; maxX = MAX_CONTAINER_WIDTH; maxY = 300;

    original_design_width = maxX - minX
    original_design_height = maxY - minY
    scale_factor = 1
    if original_design_width > MAX_CONTAINER_WIDTH and original_design_width > 0:
        scale_factor = MAX_CONTAINER_WIDTH / original_design_width

    scaled_container_height = original_design_height * scale_factor

    html_content_parts = []
    css_content_parts = []

    html_content_parts.append(f"""<!DOCTYPE html><html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Мой Сайт (ProThemesRU)</title>
    <link rel="stylesheet" href="style.css">
    <style>
        /* Базовые стили для элементов конструктора */
        .canvas-element {{
            box-sizing: border-box;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }}

        .canvas-element[style*="position: absolute;"] {{
             position: absolute;
        }}

        .canvas-element > * {{
            width: 100%;
            height: 100%;
            box-sizing: border-box;
        }}
        .text-element {{
            text-align: center;
            word-break: break-word;
            padding: 5px;
        }}        .image-element {{
            display: block;
            object-fit: contain;
            max-width: 100%;
            height: auto;
        }}
        .button-element {{            padding: 8px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            white-space: nowrap;
        }}
        .shape-element {{
            /* background-color and border-radius are inline */
        }}
    </style>
</head>
<body>
    <div id="main-content-area">""")

    css_content_parts.append(f"""
body {{
    margin: 0;
    padding: 0;
    font-family: Arial, sans-serif;    background-color: #f0f0f0;
    min-height: 100vh;
    display: flex;
    justify-content: center;
    align-items: flex-start;    padding: 20px 0;
    box-sizing: border-box;
}}

#main-content-area {{
    position: relative;
    max-width: {MAX_CONTAINER_WIDTH}px;
    width: 100%;
    margin: 0 auto;
    min-height: {max(scaled_container_height, 200)}px;
    background-color: #ffffff;
    box-shadow: 0 0 15px rgba(0, 0, 0, 0.1);
    border-radius: 8px;
    overflow: hidden;
}}
""")

    def render_element_html_and_css(element):
        # Children should also be sorted by z-index if they are rendered within a group
        children = sorted([el for el in sorted_elements if el.get('parentId') == element['id']], key=lambda x: x['props'].get('zIndex', 1))

        inline_styles = ""
        element_classes = 'canvas-element'

        parent = element.get('parentId')
        is_child_of_flex_container = False
        is_child_of_grid_container = False
        if parent:
            parent_el = element_map.get(parent)
            if parent_el and parent_el.get('type') == 'group':
                if parent_el['props'].get('displayMode') == 'flex':
                    is_child_of_flex_container = True
                elif parent_el['props'].get('displayMode') == 'grid':
                    is_child_of_grid_container = True

        if is_child_of_flex_container or is_child_of_grid_container:
            inline_styles += f"width: {element['width']}px; height: {element['height']}px;"
        else:            elX = element['x']
            elY = element['y']

            newX = (elX - minX) * scale_factor if element.get('parentId') is None else elX
            newY = (elY - minY) * scale_factor if element.get('parentId') is None else elY
            newWidth = element['width'] * scale_factor if element.get('parentId') is None else element['width']
            newHeight = element['height'] * scale_factor if element.get('parentId') is None else element['height']

            inline_styles += f"position: absolute; left: {newX}px; top: {newY}px; width: {newWidth}px; height: {newHeight}px;"

        # NEW: Apply z-index
        if element['props'].get('zIndex') is not None:
            inline_styles += f" z-index: {element['props']['zIndex']};"

        if element['props'].get('customClasses') and len(element['props']['customClasses']) > 0:
            element_classes += f" {' '.join(element['props']['customClasses'])}"
        
        inner_html = ""
        if element['type'] == 'text':
            inner_html = f'<div class="text-element">{element["props"].get("content", "")}</div>'
            inline_styles += f" font-size: {element['props'].get('fontSize', '16px')}; color: {element['props'].get('color', '#000000')};"
        elif element['type'] == 'image':
            inner_html = f'<img src="{element["props"].get("src", "")}" alt="{element["props"].get("alt", "")}" class="image-element">'
        elif element['type'] == 'button':
            inner_html = f'<button class="button-element">{element["props"].get("label", "")}</button>'
            inline_styles += f" background-color: {element['props'].get('bgColor', '#007bff')}; color: {element['props'].get('textColor', '#ffffff')};"
        elif element['type'] == 'shape':
            inner_html = f'<div class="shape-element"></div>'
            inline_styles += f" background-color: {element['props'].get('bgColor', '#ffc107')}; border-radius: {element['props'].get('borderRadius', '0')};"
        elif element['type'] == 'group':
            element_classes += ' group-element'
            if element['props'].get('displayMode') == 'flex':
                inline_styles += f" display: flex;"
                if element['props'].get('flexDirection'): inline_styles += f" flex-direction: {element['props']['flexDirection']};"
                if element['props'].get('justifyContent'): inline_styles += f" justify-content: {element['props']['justifyContent']};"
                if element['props'].get('alignItems'): inline_styles += f" align-items: {element['props']['alignItems']};"
                if element['props'].get('gap'): inline_styles += f" gap: {element['props']['gap']};"
            elif element['props'].get('displayMode') == 'grid':
                inline_styles += f" display: grid;"
                if element['props'].get('gridTemplateColumns'): inline_styles += f" grid-template-columns: {element['props']['gridTemplateColumns']};"
                if element['props'].get('gridTemplateRows'): inline_styles += f" grid-template-rows: {element['props']['gridTemplateRows']};"
                if element['props'].get('gridGap'): inline_styles += f" gap: {element['props']['gridGap']};"            else: # absolute group
                inline_styles += f" position: absolute;"
            for child in children:
                inner_html += render_element_html_and_css(child)
        else:            inner_html = f'<div>Неизвестный элемент</div>'
        
        # Apply Border properties
        if element['props'].get('borderWidth') and element['props']['borderWidth'] != '0px' and \
           element['props'].get('borderStyle') and element['props'].get('borderColor'):
            inline_styles += f" border: {element['props']['borderWidth']} {element['props']['borderStyle']} {element['props']['borderColor']};"

        # Apply Box Shadow properties
        if any(element['props'].get(prop) for prop in ['boxShadowX', 'boxShadowY', 'boxShadowBlur', 'boxShadowSpread']):
            inline_styles += f" box-shadow: {element['props'].get('boxShadowX', '0px')} {element['props'].get('boxShadowY', '0px')} {element['props'].get('boxShadowBlur', '0px')} {element['props'].get('boxShadowSpread', '0px')} {element['props'].get('boxShadowColor', 'rgba(0,0,0,0.2)')};"

        # Apply Background properties
        if element['props'].get('backgroundColor'):
            inline_styles += f" background-color: {element['props']['backgroundColor']};"
        if element['props'].get('backgroundImage'):
            inline_styles += f" background-image: url('{element['props']['backgroundImage']}');"
            inline_styles += f" background-repeat: {element['props'].get('backgroundRepeat', 'no-repeat')};"
            inline_styles += f" background-size: {element['props'].get('backgroundSize', 'cover')};"
            inline_styles += f" background-position: {element['props'].get('backgroundPosition', 'center center')};"

        if element['props'].get('customStyles'):
            inline_styles += f" {object_to_css_string(element['props']['customStyles'])}"

        return f'        <div id="{element["id"]}" class="{element_classes}" style="{inline_styles}">{inner_html}</div>'

    for el in root_elements:
        html_content_parts.append(render_element_html_and_css(el))

    html_content_parts.append(f"""    </div>
</body>
</html>""")

    return "".join(html_content_parts), "".join(css_content_parts)
 copy
8. telegram_bot.py (Без изменений)

Этот файл не требует изменений.

Инструкции по запуску и тестированию:
Обновите содержимое:

react-canvas-editor/src/components/Editor.js
react-canvas-editor/src/components/Canvas.js
react-canvas-editor/src/components/Element.js
react-canvas-editor/src/utils/exportUtils.js
flask_app/app.py * Создайте новый файл react-canvas-editor/src/components/ContextMenu.js
Создайте новый файл react-canvas-editor/src/styles/ContextMenu.css
Убедитесь, что ваш Flask-бэкенд запущен: python flask_app/app.py

Запустите React-приложение: npm start

Откройте http://localhost:3000 в браузере.

Тестирование контекстного меню:

Создайте несколько элементов разных типов.
Перетащите их так, чтобы они накладывались друг на друга.
Выберите элемент. Нажмите Ctrl+D (или Cmd+D на Mac) — элемент должен продублироваться со смещением.
Щелкните правой кнопкой мыши по элементу:
Наведите курсор на элемент и нажмите правую кнопку мыши. Должно появиться пользовательское контекстное меню.
Убедитесь, что в меню есть такие действия, как «Копировать», «Вставить», «Дублировать», «Удалить», «Сгруппировать», «Разгруппировать», «На передний план», «На задний план».
Проверьте, активны ли пункты (например, «Вставить» должно быть неактивным, если ничего не скопировано).
Попробуйте «Копировать», а затем «Вставить» (можно на фоне канваса).
Попробуйте «Дублировать».
Попробуйте «Удалить».
Тестирование Z-индекса:
Создайте 2–3 элемента и расположите их так, чтобы они перекрывали друг друга.
Выберите один из элементов, который находится «под» другим.
Правый клик -> "На передний план". Убедитесь, что он переместился на самый верх.
Выберите элемент, который находится «над» другим элементом.
Правый клик -> "На задний план". Убедитесь, что он переместился на самый низ.
Правый клик на фоне канваса:
Нажмите правую кнопку мыши на пустом месте канваса. Должно появиться контекстное меню. * Убедитесь, что в нём есть только подходящие действия (например, «Вставить» будет активным, если что-то скопировано).
Убедитесь, что при этом выбор элемента сбрасывается.
Экспорт: экспортируйте дизайн в HTML/CSS и убедитесь, что z-index корректно применяется в стилях HTML-элементов.
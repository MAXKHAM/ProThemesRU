{"ast":null,"code":"const MAX_CONTAINER_WIDTH = 960; // Максимальная ширина для адаптивного контейнера\n\nexport function generateHtmlCss(elements) {\n  // 1. Создаем карту элементов для быстрого доступа по ID\n  const elementMap = new Map(elements.map(el => [el.id, el]));\n\n  // 2. Разделяем элементы на корневые и дочерние\n  const rootElements = elements.filter(el => !el.parentId);\n\n  // 3. Находим общие границы всех корневых элементов (для main-content-area)\n  let minX = Infinity,\n    minY = Infinity;\n  let maxX = -Infinity,\n    maxY = -Infinity;\n  if (rootElements.length > 0) {\n    rootElements.forEach(el => {\n      minX = Math.min(minX, el.x);\n      minY = Math.min(minY, el.y);\n      maxX = Math.max(maxX, el.x + el.width);\n      maxY = Math.max(maxY, el.y + el.height);\n    });\n  } else {\n    // Если элементов нет, создаем минимальный пустой контейнер\n    minX = 0;\n    minY = 0;\n    maxX = MAX_CONTAINER_WIDTH;\n    maxY = 300;\n  }\n  const originalDesignWidth = maxX - minX;\n  const originalDesignHeight = maxY - minY;\n\n  // Определяем коэффициент масштабирования, если дизайн шире, чем MAX_CONTAINER_WIDTH\n  const scaleFactor = originalDesignWidth > MAX_CONTAINER_WIDTH && originalDesignWidth > 0 ? MAX_CONTAINER_WIDTH / originalDesignWidth : 1;\n  const scaledContainerHeight = originalDesignHeight * scaleFactor;\n  let htmlContent = `<!DOCTYPE html>\n<html lang=\"ru\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Мой Сайт (ProThemesRU)</title>\n    <link rel=\"stylesheet\" href=\"style.css\">\n    <style>\n        /* Базовые стили для элементов конструктора */\n        .canvas-element {\n            position: absolute;\n            box-sizing: border-box;\n            overflow: hidden;\n            display: flex;\n            align-items: center;            justify-content: center;\n        }\n        /* Для дочерних элементов внутри группы */\n        .group-element > .canvas-element {\n            position: absolute; /* Дети внутри группы тоже абсолютно позиционированы */        }\n\n        .canvas-element > * {\n            width: 100%;\n            height: 100%;\n            box-sizing: border-box;\n        }\n\n        .text-element {\n            text-align: center;\n            word-break: break-word;\n            padding: 5px;\n        }\n        .image-element {\n            display: block;\n            object-fit: contain;\n            max-width: 100%;\n            height: auto;\n        }\n        .button-element {\n            padding: 8px 15px;\n            border: none;\n            border-radius: 4px;\n            cursor: pointer;\n            font-size: 14px;\n            white-space: nowrap;\n        }\n        .shape-element {\n            /* background-color and border-radius are inline */\n        }\n    </style>\n</head>\n<body>\n    <div id=\"main-content-area\">\n`;\n  let cssContent = `\nbody {\n    margin: 0;\n    padding: 0;\n    font-family: Arial, sans-serif;\n    background-color: #f0f0f0;\n    min-height: 100vh;\n    display: flex;\n    justify-content: center; /* Центрируем контейнер по горизонтали */\n    align-items: flex-start; /* Выравниваем контейнер по верху */\n    padding: 20px 0; /* Отступ сверху/снизу */\n    box-sizing: border-box;\n}\n\n#main-content-area {\n    position: relative;\n    max-width: ${MAX_CONTAINER_WIDTH}px;\n    width: 100%; /* Обеспечиваем, что контейнер занимает всю доступную ширину до max-width */\n    margin: 0 auto; /* Центрирование */\n    min-height: ${Math.max(scaledContainerHeight, 200)}px; /* Минимальная высота, если нет элементов */\n    background-color: #ffffff;\n    box-shadow: 0 0 15px rgba(0, 0, 0, 0.1);\n    border-radius: 8px;\n    overflow: hidden; /* Обрезаем все, что выходит за границы контейнера */\n}\n`;\n  // Рекурсивная функция для рендеринга элементов\n  function renderElementHtmlAndCss(element) {\n    const children = elements.filter(el => el.parentId === element.id);\n\n    // Координаты и размеры элемента относительно его родителя (или main-content-area)\n    // Для корневых элементов (parentId: null), x/y уже относительны minX/minY канваса\n    // Для детей групп, x/y уже относительны их группы\n    const elX = element.x;\n    const elY = element.y;\n\n    // Применяем scaleFactor только к корневым элементам (или группам),\n    // а дочерние элементы уже имеют масштабированные размеры относительно родителя\n    // и будут масштабироваться при масштабировании родителя.\n    // Здесь мы масштабируем только корневые элементы и их прямые размеры.\n    // Если элемент является группой, его дети будут внутри него, и их\n    // x/y/width/height будут относительны к группе.\n    const newX = element.parentId === null ? (elX - minX) * scaleFactor : elX;\n    const newY = element.parentId === null ? (elY - minY) * scaleFactor : elY;\n    const newWidth = element.parentId === null ? element.width * scaleFactor : element.width;\n    const newHeight = element.parentId === null ? element.height * scaleFactor : element.height;\n\n    // Генерируем CSS для элемента\n    cssContent += `\n#${element.id} {\n    left: ${newX}px;\n    top: ${newY}px;\n    width: ${newWidth}px;\n    height: ${newHeight}px;\n`;\n    let innerHtml = '';\n    switch (element.type) {\n      case 'text':\n        innerHtml = `<div class=\"text-element\">${element.props.content || ''}</div>`;\n        cssContent += `\n    font-size: ${element.props.fontSize || '16px'};\n    color: ${element.props.color || '#000000'};\n`;\n        break;\n      case 'image':\n        innerHtml = `<img src=\"${element.props.src || ''}\" alt=\"${element.props.alt || ''}\" class=\"image-element\">`;\n        break;\n      case 'button':\n        innerHtml = `<button class=\"button-element\">${element.props.label || ''}</button>`;\n        cssContent += `\n    background-color: ${element.props.bgColor || '#007bff'};\n    color: ${element.props.textColor || '#ffffff'};\n`;\n        break;\n      case 'shape':\n        innerHtml = `<div class=\"shape-element\"></div>`;\n        cssContent += `\n    background-color: ${element.props.bgColor || '#ffc107'};\n    border-radius: ${element.props.borderRadius || '0'};\n`;\n        break;\n      case 'group':\n        // Для группы, её внутренний HTML будет содержать рекурсивно отрендеренные дети\n        innerHtml = children.map(child => renderElementHtmlAndCss(child)).join('\\n');\n        cssContent += `\n    /* Group specific styles */\n    position: absolute; /* Группы тоже абсолютно позиционированы */\n    background-color: rgba(255, 255, 255, 0.05); /* Легкий фон для группы */\n    border: 1px dashed rgba(0, 0, 0, 0.1); /* Пунктирная рамка для группы */\n    /* Здесь можно добавить flexbox/grid, если группа должна управлять layout детей */\n`;\n        break;\n      default:\n        innerHtml = `<div>Неизвестный элемент</div>`;\n    }\n    cssContent += `}\\n`; // Закрываем ID-селектор\n\n    // Возвращаем HTML для текущего элемента, включая его детей (если это группа)\n    return `        <div id=\"${element.id}\" class=\"canvas-element\">${innerHtml}</div>`;\n  }\n\n  // Рендерим только корневые элементы\n  htmlContent += rootElements.map(el => renderElementHtmlAndCss(el)).join('\\n');\n  htmlContent += `    </div>\n</body>\n</html>`;\n  return {\n    htmlContent,\n    cssContent\n  };\n}","map":{"version":3,"names":["MAX_CONTAINER_WIDTH","generateHtmlCss","elements","elementMap","Map","map","el","id","rootElements","filter","parentId","minX","Infinity","minY","maxX","maxY","length","forEach","Math","min","x","y","max","width","height","originalDesignWidth","originalDesignHeight","scaleFactor","scaledContainerHeight","htmlContent","cssContent","renderElementHtmlAndCss","element","children","elX","elY","newX","newY","newWidth","newHeight","innerHtml","type","props","content","fontSize","color","src","alt","label","bgColor","textColor","borderRadius","child","join"],"sources":["C:/Users/user/Desktop/ProThemesRU1/frontend/src/utils/exportUtils.js"],"sourcesContent":["const MAX_CONTAINER_WIDTH = 960; // Максимальная ширина для адаптивного контейнера\r\n\r\nexport function generateHtmlCss(elements) {\r\n    // 1. Создаем карту элементов для быстрого доступа по ID\r\n    const elementMap = new Map(elements.map(el => [el.id, el]));\r\n\r\n    // 2. Разделяем элементы на корневые и дочерние\r\n    const rootElements = elements.filter(el => !el.parentId);\r\n\r\n    // 3. Находим общие границы всех корневых элементов (для main-content-area)\r\n    let minX = Infinity, minY = Infinity;\r\n    let maxX = -Infinity, maxY = -Infinity;\r\n\r\n    if (rootElements.length > 0) {\r\n        rootElements.forEach(el => {\r\n            minX = Math.min(minX, el.x);\r\n            minY = Math.min(minY, el.y);\r\n            maxX = Math.max(maxX, el.x + el.width);\r\n            maxY = Math.max(maxY, el.y + el.height);\r\n        });\r\n    } else {\r\n        // Если элементов нет, создаем минимальный пустой контейнер\r\n        minX = 0; minY = 0; maxX = MAX_CONTAINER_WIDTH; maxY = 300;\r\n    }\r\n\r\n    const originalDesignWidth = maxX - minX;\r\n    const originalDesignHeight = maxY - minY;\r\n\r\n    // Определяем коэффициент масштабирования, если дизайн шире, чем MAX_CONTAINER_WIDTH\r\n    const scaleFactor = originalDesignWidth > MAX_CONTAINER_WIDTH && originalDesignWidth > 0\r\n        ? MAX_CONTAINER_WIDTH / originalDesignWidth\r\n        : 1;\r\n\r\n    const scaledContainerHeight = originalDesignHeight * scaleFactor;\r\n\r\n    let htmlContent = `<!DOCTYPE html>\r\n<html lang=\"ru\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Мой Сайт (ProThemesRU)</title>\r\n    <link rel=\"stylesheet\" href=\"style.css\">\r\n    <style>\r\n        /* Базовые стили для элементов конструктора */\r\n        .canvas-element {\r\n            position: absolute;\r\n            box-sizing: border-box;\r\n            overflow: hidden;\r\n            display: flex;\r\n            align-items: center;            justify-content: center;\r\n        }\r\n        /* Для дочерних элементов внутри группы */\r\n        .group-element > .canvas-element {\r\n            position: absolute; /* Дети внутри группы тоже абсолютно позиционированы */        }\r\n\r\n        .canvas-element > * {\r\n            width: 100%;\r\n            height: 100%;\r\n            box-sizing: border-box;\r\n        }\r\n\r\n        .text-element {\r\n            text-align: center;\r\n            word-break: break-word;\r\n            padding: 5px;\r\n        }\r\n        .image-element {\r\n            display: block;\r\n            object-fit: contain;\r\n            max-width: 100%;\r\n            height: auto;\r\n        }\r\n        .button-element {\r\n            padding: 8px 15px;\r\n            border: none;\r\n            border-radius: 4px;\r\n            cursor: pointer;\r\n            font-size: 14px;\r\n            white-space: nowrap;\r\n        }\r\n        .shape-element {\r\n            /* background-color and border-radius are inline */\r\n        }\r\n    </style>\r\n</head>\r\n<body>\r\n    <div id=\"main-content-area\">\r\n`;\r\n    let cssContent = `\r\nbody {\r\n    margin: 0;\r\n    padding: 0;\r\n    font-family: Arial, sans-serif;\r\n    background-color: #f0f0f0;\r\n    min-height: 100vh;\r\n    display: flex;\r\n    justify-content: center; /* Центрируем контейнер по горизонтали */\r\n    align-items: flex-start; /* Выравниваем контейнер по верху */\r\n    padding: 20px 0; /* Отступ сверху/снизу */\r\n    box-sizing: border-box;\r\n}\r\n\r\n#main-content-area {\r\n    position: relative;\r\n    max-width: ${MAX_CONTAINER_WIDTH}px;\r\n    width: 100%; /* Обеспечиваем, что контейнер занимает всю доступную ширину до max-width */\r\n    margin: 0 auto; /* Центрирование */\r\n    min-height: ${Math.max(scaledContainerHeight, 200)}px; /* Минимальная высота, если нет элементов */\r\n    background-color: #ffffff;\r\n    box-shadow: 0 0 15px rgba(0, 0, 0, 0.1);\r\n    border-radius: 8px;\r\n    overflow: hidden; /* Обрезаем все, что выходит за границы контейнера */\r\n}\r\n`;\r\n    // Рекурсивная функция для рендеринга элементов\r\n    function renderElementHtmlAndCss(element) {\r\n        const children = elements.filter(el => el.parentId === element.id);\r\n\r\n        // Координаты и размеры элемента относительно его родителя (или main-content-area)\r\n        // Для корневых элементов (parentId: null), x/y уже относительны minX/minY канваса\r\n        // Для детей групп, x/y уже относительны их группы\r\n        const elX = element.x;\r\n        const elY = element.y;\r\n\r\n        // Применяем scaleFactor только к корневым элементам (или группам),\r\n        // а дочерние элементы уже имеют масштабированные размеры относительно родителя\r\n        // и будут масштабироваться при масштабировании родителя.\r\n        // Здесь мы масштабируем только корневые элементы и их прямые размеры.\r\n        // Если элемент является группой, его дети будут внутри него, и их\r\n        // x/y/width/height будут относительны к группе.\r\n        const newX = (element.parentId === null) ? (elX - minX) * scaleFactor : elX;\r\n        const newY = (element.parentId === null) ? (elY - minY) * scaleFactor : elY;\r\n        const newWidth = (element.parentId === null) ? element.width * scaleFactor : element.width;\r\n        const newHeight = (element.parentId === null) ? element.height * scaleFactor : element.height;\r\n\r\n\r\n        // Генерируем CSS для элемента\r\n        cssContent += `\r\n#${element.id} {\r\n    left: ${newX}px;\r\n    top: ${newY}px;\r\n    width: ${newWidth}px;\r\n    height: ${newHeight}px;\r\n`;\r\n\r\n        let innerHtml = '';\r\n        switch (element.type) {\r\n            case 'text':\r\n                innerHtml = `<div class=\"text-element\">${element.props.content || ''}</div>`;\r\n                cssContent += `\r\n    font-size: ${element.props.fontSize || '16px'};\r\n    color: ${element.props.color || '#000000'};\r\n`;\r\n                break;\r\n            case 'image':\r\n                innerHtml = `<img src=\"${element.props.src || ''}\" alt=\"${element.props.alt || ''}\" class=\"image-element\">`;\r\n                break;\r\n            case 'button':\r\n                innerHtml = `<button class=\"button-element\">${element.props.label || ''}</button>`;\r\n                cssContent += `\r\n    background-color: ${element.props.bgColor || '#007bff'};\r\n    color: ${element.props.textColor || '#ffffff'};\r\n`;\r\n                break;\r\n            case 'shape':\r\n                innerHtml = `<div class=\"shape-element\"></div>`;                cssContent += `\r\n    background-color: ${element.props.bgColor || '#ffc107'};\r\n    border-radius: ${element.props.borderRadius || '0'};\r\n`;\r\n                break;            case 'group':\r\n                // Для группы, её внутренний HTML будет содержать рекурсивно отрендеренные дети\r\n                innerHtml = children.map(child => renderElementHtmlAndCss(child)).join('\\n');\r\n                cssContent += `\r\n    /* Group specific styles */\r\n    position: absolute; /* Группы тоже абсолютно позиционированы */\r\n    background-color: rgba(255, 255, 255, 0.05); /* Легкий фон для группы */\r\n    border: 1px dashed rgba(0, 0, 0, 0.1); /* Пунктирная рамка для группы */\r\n    /* Здесь можно добавить flexbox/grid, если группа должна управлять layout детей */\r\n`;\r\n                break;\r\n            default:\r\n                innerHtml = `<div>Неизвестный элемент</div>`;\r\n        }\r\n        cssContent += `}\\n`; // Закрываем ID-селектор\r\n\r\n        // Возвращаем HTML для текущего элемента, включая его детей (если это группа)\r\n        return `        <div id=\"${element.id}\" class=\"canvas-element\">${innerHtml}</div>`;\r\n    }\r\n\r\n    // Рендерим только корневые элементы\r\n    htmlContent += rootElements.map(el => renderElementHtmlAndCss(el)).join('\\n');\r\n\r\n    htmlContent += `    </div>\r\n</body>\r\n</html>`;\r\n\r\n    return { htmlContent, cssContent };\r\n} "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"const MAX_CONTAINER_WIDTH = 960; // Максимальная ширина для адаптивного контейнера\n\nexport function generateHtmlCss(elements) {\n  // 1. Находим общие границы всех элементов\n  let minX = Infinity,\n    minY = Infinity;\n  let maxX = -Infinity,\n    maxY = -Infinity;\n  if (elements.length > 0) {\n    elements.forEach(el => {\n      minX = Math.min(minX, el.x);\n      minY = Math.min(minY, el.y);\n      maxX = Math.max(maxX, el.x + el.width);\n      maxY = Math.max(maxY, el.y + el.height);\n    });\n  } else {\n    // Если элементов нет, создаем минимальный пустой контейнер\n    minX = 0;\n    minY = 0;\n    maxX = MAX_CONTAINER_WIDTH;\n    maxY = 300;\n  }\n  const originalDesignWidth = maxX - minX;\n  const originalDesignHeight = maxY - minY;\n\n  // Определяем коэффициент масштабирования, если дизайн шире, чем MAX_CONTAINER_WIDTH\n  const scaleFactor = originalDesignWidth > MAX_CONTAINER_WIDTH && originalDesignWidth > 0 ? MAX_CONTAINER_WIDTH / originalDesignWidth : 1;\n  const scaledContainerHeight = originalDesignHeight * scaleFactor;\n  let htmlContent = `<!DOCTYPE html>\n<html lang=\"ru\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Мой Дизайн (ProThemesRU)</title>\n    <link rel=\"stylesheet\" href=\"style.css\">\n    <style>\n        /* Базовые стили для элементов конструктора */\n        .canvas-element {\n            position: absolute;\n            box-sizing: border-box;\n            overflow: hidden;            /* Чтобы содержимое не вылезало за границы */\n            display: flex;\n            align-items: center;\n            justify-content: center;\n        }\n        .canvas-element > * {\n            width: 100%;\n            height: 100%;\n            box-sizing: border-box;\n        }\n\n        .text-element {\n            /* flexbox properties from canvas-element parent */\n            text-align: center;            word-break: break-word;\n            padding: 5px;\n        }\n        .image-element {\n            display: block;\n            object-fit: contain;\n            max-width: 100%; /* Добавлено для адаптивности */\n            height: auto;    /* Добавлено для адаптивности */\n        }\n        .button-element {\n            padding: 8px 15px;\n            border: none;\n            border-radius: 4px;\n            cursor: pointer;\n            font-size: 14px;\n            white-space: nowrap;\n        }\n        .shape-element {\n            /* background-color and border-radius are inline */\n        }\n    </style>\n</head>\n<body>\n    <div id=\"main-content-area\">\n`;\n  let cssContent = `\nbody {\n    margin: 0;\n    padding: 0;\n    font-family: Arial, sans-serif;\n    background-color: #f0f0f0;\n    min-height: 100vh;\n    display: flex;\n    justify-content: center; /* Центрируем контейнер по горизонтали */\n    align-items: flex-start; /* Выравниваем контейнер по верху */\n    padding: 20px 0; /* Отступ сверху/снизу */\n    box-sizing: border-box;\n}\n\n#main-content-area {\n    position: relative;    max-width: ${MAX_CONTAINER_WIDTH}px;\n    width: 100%; /* Обеспечиваем, что контейнер занимает всю доступную ширину до max-width */\n    margin: 0 auto; /* Центрирование */\n    min-height: ${Math.max(scaledContainerHeight, 200)}px; /* Минимальная высота, если нет элементов */\n    background-color: #ffffff;\n    box-shadow: 0 0 15px rgba(0, 0, 0, 0.1);\n    border-radius: 8px;\n    overflow: hidden; /* Обрезаем все, что выходит за границы контейнера */\n}\n`;\n  elements.forEach(el => {\n    // Пересчитываем координаты и размеры относительно нового контейнера и масштаба\n    const newX = (el.x - minX) * scaleFactor;\n    const newY = (el.y - minY) * scaleFactor;\n    const newWidth = el.width * scaleFactor;\n    const newHeight = el.height * scaleFactor;\n    cssContent += `\n#${el.id} {\n    left: ${newX}px;\n    top: ${newY}px;\n    width: ${newWidth}px;\n    height: ${newHeight}px;\n`;\n    let elementHtml = '';\n    switch (el.type) {\n      case 'text':\n        elementHtml = `<div class=\"text-element\">${el.props.content || ''}</div>`;\n        cssContent += `\n    font-size: ${el.props.fontSize || '16px'};\n    color: ${el.props.color || '#000000'};\n`;\n        break;\n      case 'image':\n        elementHtml = `<img src=\"${el.props.src || ''}\" alt=\"${el.props.alt || ''}\" class=\"image-element\">`;\n        break;\n      case 'button':\n        elementHtml = `<button class=\"button-element\">${el.props.label || ''}</button>`;\n        cssContent += `    background-color: ${el.props.bgColor || '#007bff'};\n    color: ${el.props.textColor || '#ffffff'};\n`;\n        break;\n      case 'shape':\n        elementHtml = `<div class=\"shape-element\"></div>`;\n        cssContent += `\n    background-color: ${el.props.bgColor || '#ffc107'};\n    border-radius: ${el.props.borderRadius || '0'};\n`;\n        break;\n      default:\n        elementHtml = `<div>Неизвестный элемент</div>`;\n    }\n    cssContent += `}\\n`; // Закрываем ID-селектор\n\n    htmlContent += `        <div id=\"${el.id}\" class=\"canvas-element\">${elementHtml}</div>\\n`;\n  });\n  htmlContent += `    </div>\n</body>\n</html>`;\n  return {\n    htmlContent,\n    cssContent\n  };\n}","map":{"version":3,"names":["MAX_CONTAINER_WIDTH","generateHtmlCss","elements","minX","Infinity","minY","maxX","maxY","length","forEach","el","Math","min","x","y","max","width","height","originalDesignWidth","originalDesignHeight","scaleFactor","scaledContainerHeight","htmlContent","cssContent","newX","newY","newWidth","newHeight","id","elementHtml","type","props","content","fontSize","color","src","alt","label","bgColor","textColor","borderRadius"],"sources":["C:/Users/user/Desktop/ProThemesRU1/frontend/src/utils/exportUtils.js"],"sourcesContent":["const MAX_CONTAINER_WIDTH = 960; // Максимальная ширина для адаптивного контейнера\r\n\r\nexport function generateHtmlCss(elements) {\r\n    // 1. Находим общие границы всех элементов\r\n    let minX = Infinity, minY = Infinity;\r\n    let maxX = -Infinity, maxY = -Infinity;\r\n\r\n    if (elements.length > 0) {\r\n        elements.forEach(el => {\r\n            minX = Math.min(minX, el.x);\r\n            minY = Math.min(minY, el.y);\r\n            maxX = Math.max(maxX, el.x + el.width);\r\n            maxY = Math.max(maxY, el.y + el.height);\r\n        });\r\n    } else {\r\n        // Если элементов нет, создаем минимальный пустой контейнер\r\n        minX = 0; minY = 0; maxX = MAX_CONTAINER_WIDTH; maxY = 300;\r\n    }\r\n\r\n    const originalDesignWidth = maxX - minX;\r\n    const originalDesignHeight = maxY - minY;\r\n\r\n    // Определяем коэффициент масштабирования, если дизайн шире, чем MAX_CONTAINER_WIDTH\r\n    const scaleFactor = originalDesignWidth > MAX_CONTAINER_WIDTH && originalDesignWidth > 0\r\n        ? MAX_CONTAINER_WIDTH / originalDesignWidth\r\n        : 1;\r\n\r\n    const scaledContainerHeight = originalDesignHeight * scaleFactor;\r\n\r\n    let htmlContent = `<!DOCTYPE html>\r\n<html lang=\"ru\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Мой Дизайн (ProThemesRU)</title>\r\n    <link rel=\"stylesheet\" href=\"style.css\">\r\n    <style>\r\n        /* Базовые стили для элементов конструктора */\r\n        .canvas-element {\r\n            position: absolute;\r\n            box-sizing: border-box;\r\n            overflow: hidden;            /* Чтобы содержимое не вылезало за границы */\r\n            display: flex;\r\n            align-items: center;\r\n            justify-content: center;\r\n        }\r\n        .canvas-element > * {\r\n            width: 100%;\r\n            height: 100%;\r\n            box-sizing: border-box;\r\n        }\r\n\r\n        .text-element {\r\n            /* flexbox properties from canvas-element parent */\r\n            text-align: center;            word-break: break-word;\r\n            padding: 5px;\r\n        }\r\n        .image-element {\r\n            display: block;\r\n            object-fit: contain;\r\n            max-width: 100%; /* Добавлено для адаптивности */\r\n            height: auto;    /* Добавлено для адаптивности */\r\n        }\r\n        .button-element {\r\n            padding: 8px 15px;\r\n            border: none;\r\n            border-radius: 4px;\r\n            cursor: pointer;\r\n            font-size: 14px;\r\n            white-space: nowrap;\r\n        }\r\n        .shape-element {\r\n            /* background-color and border-radius are inline */\r\n        }\r\n    </style>\r\n</head>\r\n<body>\r\n    <div id=\"main-content-area\">\r\n`;\r\n    let cssContent = `\r\nbody {\r\n    margin: 0;\r\n    padding: 0;\r\n    font-family: Arial, sans-serif;\r\n    background-color: #f0f0f0;\r\n    min-height: 100vh;\r\n    display: flex;\r\n    justify-content: center; /* Центрируем контейнер по горизонтали */\r\n    align-items: flex-start; /* Выравниваем контейнер по верху */\r\n    padding: 20px 0; /* Отступ сверху/снизу */\r\n    box-sizing: border-box;\r\n}\r\n\r\n#main-content-area {\r\n    position: relative;    max-width: ${MAX_CONTAINER_WIDTH}px;\r\n    width: 100%; /* Обеспечиваем, что контейнер занимает всю доступную ширину до max-width */\r\n    margin: 0 auto; /* Центрирование */\r\n    min-height: ${Math.max(scaledContainerHeight, 200)}px; /* Минимальная высота, если нет элементов */\r\n    background-color: #ffffff;\r\n    box-shadow: 0 0 15px rgba(0, 0, 0, 0.1);\r\n    border-radius: 8px;\r\n    overflow: hidden; /* Обрезаем все, что выходит за границы контейнера */\r\n}\r\n`;\r\n\r\n    elements.forEach(el => {\r\n        // Пересчитываем координаты и размеры относительно нового контейнера и масштаба\r\n        const newX = (el.x - minX) * scaleFactor;        const newY = (el.y - minY) * scaleFactor;\r\n        const newWidth = el.width * scaleFactor;\r\n        const newHeight = el.height * scaleFactor;\r\n\r\n        cssContent += `\r\n#${el.id} {\r\n    left: ${newX}px;\r\n    top: ${newY}px;\r\n    width: ${newWidth}px;\r\n    height: ${newHeight}px;\r\n`;\r\n\r\n        let elementHtml = '';\r\n        switch (el.type) {\r\n            case 'text':\r\n                elementHtml = `<div class=\"text-element\">${el.props.content || ''}</div>`;\r\n                cssContent += `\r\n    font-size: ${el.props.fontSize || '16px'};\r\n    color: ${el.props.color || '#000000'};\r\n`;\r\n                break;\r\n            case 'image':\r\n                elementHtml = `<img src=\"${el.props.src || ''}\" alt=\"${el.props.alt || ''}\" class=\"image-element\">`;\r\n                break;\r\n            case 'button':\r\n                elementHtml = `<button class=\"button-element\">${el.props.label || ''}</button>`;\r\n                cssContent += `    background-color: ${el.props.bgColor || '#007bff'};\r\n    color: ${el.props.textColor || '#ffffff'};\r\n`;\r\n                break;\r\n            case 'shape':\r\n                elementHtml = `<div class=\"shape-element\"></div>`;\r\n                cssContent += `\r\n    background-color: ${el.props.bgColor || '#ffc107'};\r\n    border-radius: ${el.props.borderRadius || '0'};\r\n`;\r\n                break;\r\n            default:\r\n                elementHtml = `<div>Неизвестный элемент</div>`;\r\n        }\r\n        cssContent += `}\\n`; // Закрываем ID-селектор\r\n\r\n        htmlContent += `        <div id=\"${el.id}\" class=\"canvas-element\">${elementHtml}</div>\\n`;\r\n    });\r\n\r\n    htmlContent += `    </div>\r\n</body>\r\n</html>`;\r\n\r\n    return { htmlContent, cssContent };\r\n} "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
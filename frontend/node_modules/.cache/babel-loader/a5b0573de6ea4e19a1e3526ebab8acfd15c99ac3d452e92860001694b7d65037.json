{"ast":null,"code":"const MAX_CONTAINER_WIDTH = 960; // Максимальная ширина для адаптивного контейнера\n\nexport function cssStringToObject(cssString) {\n  const styles = {};\n  if (!cssString) return styles;\n  cssString = cssString.replace(/\\/\\*[\\s\\S]*?\\*\\/|([^:]|^)\\/\\/.*$/gm, '$1');\n  const parts = cssString.split(';');\n  parts.forEach(part => {\n    const trimmedPart = part.trim();\n    if (trimmedPart) {\n      const colonIndex = trimmedPart.indexOf(':');\n      if (colonIndex > 0) {\n        const key = trimmedPart.substring(0, colonIndex).trim();\n        const value = trimmedPart.substring(colonIndex + 1).trim();\n        if (key && value) {\n          styles[key] = value;\n        }\n      }\n    }\n  });\n  return styles;\n}\nexport function objectToCssString(cssObject) {\n  if (!cssObject) return \"\";\n  return Object.entries(cssObject).map(([key, value]) => `${key}: ${value}`).join('; ') + (Object.keys(cssObject).length > 0 ? ';' : '');\n}\nexport function generateHtmlCss(elements) {\n  // 1. Создаем карту элементов для быстрого доступа по ID\n  const elementMap = new Map(elements.map(el => [el.id, el]));\n\n  // 2. Разделяем элементы на корневые и дочерние\n  const rootElements = elements.filter(el => !el.parentId);\n\n  // 3. Находим общие границы всех корневых элементов (для main-content-area)\n  let minX = Infinity,\n    minY = Infinity;\n  let maxX = -Infinity,\n    maxY = -Infinity;\n  if (rootElements.length > 0) {\n    rootElements.forEach(el => {\n      minX = Math.min(minX, el.x);\n      minY = Math.min(minY, el.y);\n      maxX = Math.max(maxX, el.x + el.width);\n      maxY = Math.max(maxY, el.y + el.height);\n    });\n  } else {\n    // Если элементов нет, создаем минимальный пустой контейнер\n    minX = 0;\n    minY = 0;\n    maxX = MAX_CONTAINER_WIDTH;\n    maxY = 300;\n  }\n  const originalDesignWidth = maxX - minX;\n  const originalDesignHeight = maxY - minY;\n\n  // Определяем коэффициент масштабирования, если дизайн шире, чем MAX_CONTAINER_WIDTH\n  const scaleFactor = originalDesignWidth > MAX_CONTAINER_WIDTH && originalDesignWidth > 0 ? MAX_CONTAINER_WIDTH / originalDesignWidth : 1;\n  const scaledContainerHeight = originalDesignHeight * scaleFactor;\n  let htmlContent = `<!DOCTYPE html>\n<html lang=\"ru\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Мой Сайт (ProThemesRU)</title>\n    <link rel=\"stylesheet\" href=\"style.css\">\n    <style>\n        /* Базовые стили для элементов конструктора */\n        .canvas-element {\n            position: absolute;\n            box-sizing: border-box;\n            overflow: hidden;\n            display: flex;\n            align-items: center;            justify-content: center;\n        }\n        /* Для дочерних элементов внутри группы */\n        .group-element > .canvas-element {\n            position: absolute; /* Дети внутри группы тоже абсолютно позиционированы */        }\n\n        .canvas-element > * {\n            width: 100%;\n            height: 100%;\n            box-sizing: border-box;\n        }\n\n        .text-element {\n            text-align: center;\n            word-break: break-word;\n            padding: 5px;\n        }\n        .image-element {\n            display: block;\n            object-fit: contain;\n            max-width: 100%;\n            height: auto;\n        }\n        .button-element {\n            padding: 8px 15px;\n            border: none;\n            border-radius: 4px;\n            cursor: pointer;\n            font-size: 14px;\n            white-space: nowrap;\n        }\n        .shape-element {\n            /* background-color and border-radius are inline */\n        }\n    </style>\n</head>\n<body>\n    <div id=\"main-content-area\">\n`;\n  let cssContent = `\nbody {\n    margin: 0;\n    padding: 0;\n    font-family: Arial, sans-serif;\n    background-color: #f0f0f0;\n    min-height: 100vh;\n    display: flex;\n    justify-content: center; /* Центрируем контейнер по горизонтали */\n    align-items: flex-start; /* Выравниваем контейнер по верху */\n    padding: 20px 0; /* Отступ сверху/снизу */\n    box-sizing: border-box;\n}\n\n#main-content-area {\n    position: relative;\n    max-width: ${MAX_CONTAINER_WIDTH}px;\n    width: 100%; /* Обеспечиваем, что контейнер занимает всю доступную ширину до max-width */\n    margin: 0 auto; /* Центрирование */\n    min-height: ${Math.max(scaledContainerHeight, 200)}px; /* Минимальная высота, если нет элементов */\n    background-color: #ffffff;\n    box-shadow: 0 0 15px rgba(0, 0, 0, 0.1);\n    border-radius: 8px;\n    overflow: hidden; /* Обрезаем все, что выходит за границы контейнера */\n}\n`;\n  // Рекурсивная функция для рендеринга элементов\n  function renderElementHtmlAndCss(element) {\n    const children = elements.filter(el => el.parentId === element.id);\n\n    // Координаты и размеры элемента относительно его родителя (или main-content-area)\n    // Для корневых элементов (parentId: null), x/y уже относительны minX/minY канваса\n    // Для детей групп, x/y уже относительны их группы\n    const elX = element.x;\n    const elY = element.y;\n\n    // Применяем scaleFactor только к корневым элементам (или группам),\n    // а дочерние элементы уже имеют масштабированные размеры относительно родителя\n    // и будут масштабироваться при масштабировании родителя.\n    // Здесь мы масштабируем только корневые элементы и их прямые размеры.\n    // Если элемент является группой, его дети будут внутри него, и их\n    // x/y/width/height будут относительны к группе.\n    const newX = element.parentId === null ? (elX - minX) * scaleFactor : elX;\n    const newY = element.parentId === null ? (elY - minY) * scaleFactor : elY;\n    const newWidth = element.parentId === null ? element.width * scaleFactor : element.width;\n    const newHeight = element.parentId === null ? element.height * scaleFactor : element.height;\n\n    // Генерируем CSS для элемента\n    cssContent += `\n#${element.id} {\n    left: ${newX}px;\n    top: ${newY}px;\n    width: ${newWidth}px;\n    height: ${newHeight}px;\n`;\n    let innerHtml = '';\n    switch (element.type) {\n      case 'text':\n        innerHtml = `<div class=\"text-element\">${element.props.content || ''}</div>`;\n        cssContent += `\n    font-size: ${element.props.fontSize || '16px'};\n    color: ${element.props.color || '#000000'};\n`;\n        break;\n      case 'image':\n        innerHtml = `<img src=\"${element.props.src || ''}\" alt=\"${element.props.alt || ''}\" class=\"image-element\">`;\n        break;\n      case 'button':\n        innerHtml = `<button class=\"button-element\">${element.props.label || ''}</button>`;\n        cssContent += `\n    background-color: ${element.props.bgColor || '#007bff'};\n    color: ${element.props.textColor || '#ffffff'};\n`;\n        break;\n      case 'shape':\n        innerHtml = `<div class=\"shape-element\"></div>`;\n        cssContent += `\n    background-color: ${element.props.bgColor || '#ffc107'};\n    border-radius: ${element.props.borderRadius || '0'};\n`;\n        break;\n      case 'group':\n        // Для группы, её внутренний HTML будет содержать рекурсивно отрендеренные дети\n        innerHtml = children.map(child => renderElementHtmlAndCss(child)).join('\\n');\n        cssContent += `\n    /* Group specific styles */\n    position: absolute; /* Группы тоже абсолютно позиционированы */\n    background-color: rgba(255, 255, 255, 0.05); /* Легкий фон для группы */\n    border: 1px dashed rgba(0, 0, 0, 0.1); /* Пунктирная рамка для группы */\n    /* Здесь можно добавить flexbox/grid, если группа должна управлять layout детей */\n`;\n        break;\n      default:\n        innerHtml = `<div>Неизвестный элемент</div>`;\n    }\n    cssContent += `}\\n`; // Закрываем ID-селектор\n\n    // Возвращаем HTML для текущего элемента, включая его детей (если это группа)\n    return `        <div id=\"${element.id}\" class=\"canvas-element\">${innerHtml}</div>`;\n  }\n\n  // Рендерим только корневые элементы\n  htmlContent += rootElements.map(el => renderElementHtmlAndCss(el)).join('\\n');\n  htmlContent += `    </div>\n</body>\n</html>`;\n  return {\n    htmlContent,\n    cssContent\n  };\n}","map":{"version":3,"names":["MAX_CONTAINER_WIDTH","cssStringToObject","cssString","styles","replace","parts","split","forEach","part","trimmedPart","trim","colonIndex","indexOf","key","substring","value","objectToCssString","cssObject","Object","entries","map","join","keys","length","generateHtmlCss","elements","elementMap","Map","el","id","rootElements","filter","parentId","minX","Infinity","minY","maxX","maxY","Math","min","x","y","max","width","height","originalDesignWidth","originalDesignHeight","scaleFactor","scaledContainerHeight","htmlContent","cssContent","renderElementHtmlAndCss","element","children","elX","elY","newX","newY","newWidth","newHeight","innerHtml","type","props","content","fontSize","color","src","alt","label","bgColor","textColor","borderRadius","child"],"sources":["C:/Users/user/Desktop/ProThemesRU1/frontend/src/utils/exportUtils.js"],"sourcesContent":["const MAX_CONTAINER_WIDTH = 960; // Максимальная ширина для адаптивного контейнера\r\n\r\nexport function cssStringToObject(cssString) {\r\n    const styles = {};\r\n    if (!cssString) return styles;\r\n    cssString = cssString.replace(/\\/\\*[\\s\\S]*?\\*\\/|([^:]|^)\\/\\/.*$/gm, '$1');\r\n    const parts = cssString.split(';');\r\n    parts.forEach(part => {\r\n        const trimmedPart = part.trim();\r\n        if (trimmedPart) {\r\n            const colonIndex = trimmedPart.indexOf(':');\r\n            if (colonIndex > 0) {\r\n                const key = trimmedPart.substring(0, colonIndex).trim();\r\n                const value = trimmedPart.substring(colonIndex + 1).trim();\r\n                if (key && value) {\r\n                    styles[key] = value;\r\n                }\r\n            }\r\n        }\r\n    });\r\n    return styles;\r\n}\r\n\r\nexport function objectToCssString(cssObject) {\r\n    if (!cssObject) return \"\";\r\n    return Object.entries(cssObject)\r\n        .map(([key, value]) => `${key}: ${value}`)\r\n        .join('; ') + (Object.keys(cssObject).length > 0 ? ';' : '');\r\n}\r\n\r\nexport function generateHtmlCss(elements) {\r\n    // 1. Создаем карту элементов для быстрого доступа по ID\r\n    const elementMap = new Map(elements.map(el => [el.id, el]));\r\n\r\n    // 2. Разделяем элементы на корневые и дочерние\r\n    const rootElements = elements.filter(el => !el.parentId);\r\n\r\n    // 3. Находим общие границы всех корневых элементов (для main-content-area)\r\n    let minX = Infinity, minY = Infinity;\r\n    let maxX = -Infinity, maxY = -Infinity;\r\n\r\n    if (rootElements.length > 0) {\r\n        rootElements.forEach(el => {\r\n            minX = Math.min(minX, el.x);\r\n            minY = Math.min(minY, el.y);\r\n            maxX = Math.max(maxX, el.x + el.width);\r\n            maxY = Math.max(maxY, el.y + el.height);\r\n        });\r\n    } else {\r\n        // Если элементов нет, создаем минимальный пустой контейнер\r\n        minX = 0; minY = 0; maxX = MAX_CONTAINER_WIDTH; maxY = 300;\r\n    }\r\n\r\n    const originalDesignWidth = maxX - minX;\r\n    const originalDesignHeight = maxY - minY;\r\n\r\n    // Определяем коэффициент масштабирования, если дизайн шире, чем MAX_CONTAINER_WIDTH\r\n    const scaleFactor = originalDesignWidth > MAX_CONTAINER_WIDTH && originalDesignWidth > 0\r\n        ? MAX_CONTAINER_WIDTH / originalDesignWidth\r\n        : 1;\r\n\r\n    const scaledContainerHeight = originalDesignHeight * scaleFactor;\r\n\r\n    let htmlContent = `<!DOCTYPE html>\r\n<html lang=\"ru\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Мой Сайт (ProThemesRU)</title>\r\n    <link rel=\"stylesheet\" href=\"style.css\">\r\n    <style>\r\n        /* Базовые стили для элементов конструктора */\r\n        .canvas-element {\r\n            position: absolute;\r\n            box-sizing: border-box;\r\n            overflow: hidden;\r\n            display: flex;\r\n            align-items: center;            justify-content: center;\r\n        }\r\n        /* Для дочерних элементов внутри группы */\r\n        .group-element > .canvas-element {\r\n            position: absolute; /* Дети внутри группы тоже абсолютно позиционированы */        }\r\n\r\n        .canvas-element > * {\r\n            width: 100%;\r\n            height: 100%;\r\n            box-sizing: border-box;\r\n        }\r\n\r\n        .text-element {\r\n            text-align: center;\r\n            word-break: break-word;\r\n            padding: 5px;\r\n        }\r\n        .image-element {\r\n            display: block;\r\n            object-fit: contain;\r\n            max-width: 100%;\r\n            height: auto;\r\n        }\r\n        .button-element {\r\n            padding: 8px 15px;\r\n            border: none;\r\n            border-radius: 4px;\r\n            cursor: pointer;\r\n            font-size: 14px;\r\n            white-space: nowrap;\r\n        }\r\n        .shape-element {\r\n            /* background-color and border-radius are inline */\r\n        }\r\n    </style>\r\n</head>\r\n<body>\r\n    <div id=\"main-content-area\">\r\n`;\r\n    let cssContent = `\r\nbody {\r\n    margin: 0;\r\n    padding: 0;\r\n    font-family: Arial, sans-serif;\r\n    background-color: #f0f0f0;\r\n    min-height: 100vh;\r\n    display: flex;\r\n    justify-content: center; /* Центрируем контейнер по горизонтали */\r\n    align-items: flex-start; /* Выравниваем контейнер по верху */\r\n    padding: 20px 0; /* Отступ сверху/снизу */\r\n    box-sizing: border-box;\r\n}\r\n\r\n#main-content-area {\r\n    position: relative;\r\n    max-width: ${MAX_CONTAINER_WIDTH}px;\r\n    width: 100%; /* Обеспечиваем, что контейнер занимает всю доступную ширину до max-width */\r\n    margin: 0 auto; /* Центрирование */\r\n    min-height: ${Math.max(scaledContainerHeight, 200)}px; /* Минимальная высота, если нет элементов */\r\n    background-color: #ffffff;\r\n    box-shadow: 0 0 15px rgba(0, 0, 0, 0.1);\r\n    border-radius: 8px;\r\n    overflow: hidden; /* Обрезаем все, что выходит за границы контейнера */\r\n}\r\n`;\r\n    // Рекурсивная функция для рендеринга элементов\r\n    function renderElementHtmlAndCss(element) {\r\n        const children = elements.filter(el => el.parentId === element.id);\r\n\r\n        // Координаты и размеры элемента относительно его родителя (или main-content-area)\r\n        // Для корневых элементов (parentId: null), x/y уже относительны minX/minY канваса\r\n        // Для детей групп, x/y уже относительны их группы\r\n        const elX = element.x;\r\n        const elY = element.y;\r\n\r\n        // Применяем scaleFactor только к корневым элементам (или группам),\r\n        // а дочерние элементы уже имеют масштабированные размеры относительно родителя\r\n        // и будут масштабироваться при масштабировании родителя.\r\n        // Здесь мы масштабируем только корневые элементы и их прямые размеры.\r\n        // Если элемент является группой, его дети будут внутри него, и их\r\n        // x/y/width/height будут относительны к группе.\r\n        const newX = (element.parentId === null) ? (elX - minX) * scaleFactor : elX;\r\n        const newY = (element.parentId === null) ? (elY - minY) * scaleFactor : elY;\r\n        const newWidth = (element.parentId === null) ? element.width * scaleFactor : element.width;\r\n        const newHeight = (element.parentId === null) ? element.height * scaleFactor : element.height;\r\n\r\n\r\n        // Генерируем CSS для элемента\r\n        cssContent += `\r\n#${element.id} {\r\n    left: ${newX}px;\r\n    top: ${newY}px;\r\n    width: ${newWidth}px;\r\n    height: ${newHeight}px;\r\n`;\r\n\r\n        let innerHtml = '';\r\n        switch (element.type) {\r\n            case 'text':\r\n                innerHtml = `<div class=\"text-element\">${element.props.content || ''}</div>`;\r\n                cssContent += `\r\n    font-size: ${element.props.fontSize || '16px'};\r\n    color: ${element.props.color || '#000000'};\r\n`;\r\n                break;\r\n            case 'image':\r\n                innerHtml = `<img src=\"${element.props.src || ''}\" alt=\"${element.props.alt || ''}\" class=\"image-element\">`;\r\n                break;\r\n            case 'button':\r\n                innerHtml = `<button class=\"button-element\">${element.props.label || ''}</button>`;\r\n                cssContent += `\r\n    background-color: ${element.props.bgColor || '#007bff'};\r\n    color: ${element.props.textColor || '#ffffff'};\r\n`;\r\n                break;\r\n            case 'shape':\r\n                innerHtml = `<div class=\"shape-element\"></div>`;                cssContent += `\r\n    background-color: ${element.props.bgColor || '#ffc107'};\r\n    border-radius: ${element.props.borderRadius || '0'};\r\n`;\r\n                break;            case 'group':\r\n                // Для группы, её внутренний HTML будет содержать рекурсивно отрендеренные дети\r\n                innerHtml = children.map(child => renderElementHtmlAndCss(child)).join('\\n');\r\n                cssContent += `\r\n    /* Group specific styles */\r\n    position: absolute; /* Группы тоже абсолютно позиционированы */\r\n    background-color: rgba(255, 255, 255, 0.05); /* Легкий фон для группы */\r\n    border: 1px dashed rgba(0, 0, 0, 0.1); /* Пунктирная рамка для группы */\r\n    /* Здесь можно добавить flexbox/grid, если группа должна управлять layout детей */\r\n`;\r\n                break;\r\n            default:\r\n                innerHtml = `<div>Неизвестный элемент</div>`;\r\n        }\r\n        cssContent += `}\\n`; // Закрываем ID-селектор\r\n\r\n        // Возвращаем HTML для текущего элемента, включая его детей (если это группа)\r\n        return `        <div id=\"${element.id}\" class=\"canvas-element\">${innerHtml}</div>`;\r\n    }\r\n\r\n    // Рендерим только корневые элементы\r\n    htmlContent += rootElements.map(el => renderElementHtmlAndCss(el)).join('\\n');\r\n\r\n    htmlContent += `    </div>\r\n</body>\r\n</html>`;\r\n\r\n    return { htmlContent, cssContent };\r\n} "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}